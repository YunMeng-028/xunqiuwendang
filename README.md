# 电子烟 Telegram Bot 产品需求文档 (PRD) - 最终版

## 📋 文档信息
- **版本**：v2.0 Final
- **更新日期**：2024-12-20
- **产品名称**：全自动电子烟售卖 Telegram Bot
- **文档状态**：最终确认版

---

## 🎯 产品概述

### 产品定位
一个基于 Telegram Bot 的全自动电子烟售卖平台，支持多国家、多地区、多语言运营。所有功能（前端购买和后台管理）均通过同一个 Telegram Bot 完成，不同管理员使用不同的Bot进行管理和运营，无任何Web端界面。系统支持多级权限管理，实现从商品浏览到配送完成的全流程自动化。

### 核心价值主张
1. **C端用户价值**：
   - 免注册即可使用，基于 Telegram ID 自动识别
   - 支付方式多样（汇旺、USDT、ETH）
   - 配送及时，全程可追踪
   - 会员体系完善，积分可抽奖/兑换

2. **B端商家价值**：
   - 独立商品管理权限
   - 灵活定价策略
   - 固定地区经营保护
   - 直接收款，资金独立

3. **管理员价值**：
   - 完整独立运营系统
   - 多商家管理能力
   - 实时数据监控
   - 自动化财务结算

4. **超级管理员价值**：
   - 软件使用权销售收入
   - 全平台数据透明
   - 多管理员体系管理
   - 平台级配置控制

### 目标用户画像
- **终端消费者**：全球电子烟用户（主要覆盖中文用户）
- **地区商家**：有固定货源的地区供应商
- **独立运营商**：希望运营电子烟销售平台的创业者
- **配送人员**：当地的配送服务提供者

---

## � 系统硬性规则和数据管理

### 权限体系（硬性数据，不可更改）
- **超级管理员**：最高权限，可售卖软件给管理员，查看所有数据
- **管理员**：独立运营权限，管理自己的客户和订单
- **商家**：地区性商品供应商，仅能管理指定地区业务
- **配送员**：负责订单配送执行，仅能查看分配订单
- **客服员**：处理支付确认和用户问题，具有订单处理权限
- **会员用户**：可见会员专属商品，享受会员特权
- **普通用户**：不可见会员商品，基础功能权限

### 数据管理规则（硬性数据，不可更改）
1. **订单清理机制**：
   - 已支付订单：12小时后物理删除
   - 未支付订单：24小时后物理删除
   - 删除前通知：自动通知超级管理员和对应管理员

2. **支持国家列表**（硬性数据，不可更改）：
   - 🇹🇭 泰国 (Thailand)
   - 🇻🇳 越南 (Vietnam)  
   - 🇱🇦 老挝 (Laos)
   - 🇲🇲 缅甸 (Myanmar)
   - 🇦🇪 迪拜 (Dubai)
   - 🇲🇾 马来西亚 (Malaysia)
   - 🇸🇬 新加坡 (Singapore)
   - 🇰🇷 韩国 (South Korea)

---

## ���👥 用户角色与权限体系

### 1. 超级管理员（Super Admin）
**角色定义**：平台拥有者，拥有最高权限

**核心权限明细**：
- **软件销售**：
  - 设置软件使用权价格（月度/半年/永久）
  - 审核管理员 Token 申请
  - 查看所有管理员运营数据
  - 接收软件购买订单收入
- **平台管理**：
  - 配置全局支付方式
  - 管理多语言包
  - 设置平台级参数（提现限额、订单清理时间等）
  - 查看所有管理员的经营数据
- **数据管理权限**：
  - 接收所有订单删除通知（已支付订单12小时后、未支付订单24小时后）
  - 监控系统数据清理状态
  - 管理跨管理员数据统计
- **通知接收**：
  - 接收所有订单删除通知
  - 接收管理员异常行为警告
  - 接收系统级错误报告

### 2. 管理员（Admin）
**角色定义**：购买软件使用权后的独立运营者

**获取方式**：
- 向超级管理员购买使用权（月度/半年/永久）
- 在超级管理员后台点击“连接我的 Bot”，跳转至 Telegram 授权页面
- 管理员登录 Telegram 并授权平台控制其 Bot
- 后端接收回调 code 并交换访问令牌，平台代表该 Bot 调用 API
- 授权成功后自动开通权限；可随时在 Telegram 端撤销授权

**核心权限明细**：
- **商家管理**：
  - 审核商家入驻申请
  - 查看商家保证金和租金状态
  - 冻结/解冻商家权限
  - 设置商家月租金额（可配置）
- **运营管理**：
  - 完整的后台菜单访问权限
  - 独立的收款账户配置
  - 查看平台运营数据
  - 管理配送员和客服员
- **财务独立**：
  - 用户付款直接进入管理员配置的收款地址
  - 自主处理提现审核
  - 独立的财务报表
- **限制事项**：
  - 无法看到其他管理员数据
  - 无法修改平台级配置
  - 无法访问超级管理员专属功能

### 3. 商家（Merchant）
**角色定义**：地区性商品供应商，仅能管理指定地区业务

**入驻流程**：
1. 向管理员提交入驻申请，并提交资质信息用于背景审核（KYB - Know Your Business）。
2. 管理员根据商家的信誉、潜在交易量等因素，设定并通知商家需缴纳的保证金（可动态调整）。
3. 商家缴纳指定金额的保证金。
4. 商家缴纳首月租金（500 USDT）。
5. 商家在后台提供用于接收加密货币的钱包扩展公钥（xpub），用于系统自动生成收款地址和确认。
6. 管理员审核通过，开通商家权限。

**核心权限明细**：
- **商品管理**：
  - 添加/编辑/删除自己的商品
  - 设置商品价格（支持阶梯价）
  - 管理商品库存
  - 上架/下架商品
- **订单处理**：
  - 查看自己商品的订单
  - 通过系统自动生成的子地址直接收取用户付款
  - 在后台配置自己的收款钱包扩展公钥（xpub）
- **数据查看**：
  - 销售数据统计
  - 库存预警提醒
- **限制事项**：
  - 只能在指定地区经营（不可更改）
  - 无法查看其他商家数据
  - 无法售卖软件使用权
  - 无法管理其他商家
  - 商品需管理员审核后才能上架

**租金机制**：
- **首月**：保证金 + 500 USDT 固定租金。
- **续费**：从第二个月起，租金为上一个自然月销售总额的5%，但最低不少于500 USDT。每月到期前3天系统自动计算并发送续费提醒。
- **欠费处理**：到期未续费自动冻结商品上架权限。
- **补缴窗口**：冻结后仍可补缴租金恢复权限。

#### 详细商家租金计算系统

**销售额统计规则**：
```
统计周期：自然月1日00:00至月末23:59
统计基数：已完成订单的商品金额（不含配送费）
排除项目：
- 退款订单不计入销售额
- 申诉中的订单暂不计入
- 申诉败诉的订单需补计入销售额

计算示例：
上月销售总额：12,000 USDT
租金计算：12,000 × 5% = 600 USDT
最低租金：500 USDT
实际应缴：600 USDT（取较大值）
```

**续费提醒机制**：
```
提醒时间表：
到期前7天：首次提醒 + 预计算租金
到期前3天：二次提醒 + 确认租金金额  
到期前1天：最后提醒 + 紧急缴费入口
到期当天：冻结通知 + 7天补缴说明

提醒消息格式：
🏪【租金提醒】🏪
━━━━━━━━━━━━━━━━━
📊 上月销售额：12,000 USDT
💰 应缴租金：600 USDT
⏰ 缴费截止：2024-02-01 00:00
━━━━━━━━━━━━━━━━━
💡 缴费方式：
🔸 USDT-TRC20：TB7z...k9X2
🔸 USDT-ERC20：0x8f4...2a1E
━━━━━━━━━━━━━━━━━
[💳 立即缴费] [📊 销售明细] [💬 联系客服]
```

**欠费处理流程**：
```
第1阶段：到期日00:00自动执行
- 冻结所有商品的上架权限
- 已上架商品自动下架
- 保留商家后台查看权限
- 发送冻结通知

第2阶段：7天补缴期内
- 可查看销售数据和订单
- 可申请人工审核租金金额
- 可通过补缴入口恢复权限
- 每日发送补缴提醒

第3阶段：7天后仍未缴费
- 永久冻结商家权限
- 保证金不退还
- 30天后账户数据归档
- 需重新申请入驻
```

**动态租金调整机制**：
- 新商家前3个月享受租金5折优惠最低500USDT
- 月销售额超过50,000 USDT可申请租金比例降至3%
- 连续6个月准时缴费可享受次年租金9折优惠
- 特殊情况可申请租金减免

### 4. 配送员（Delivery Staff）
**角色定义**：负责订单配送的执行人员

**工作流程**：
1. **接收订单**：系统按地区配送员列表顺序自动分配
2. **接单确认**：收到通知后10分钟内需确认接单
3. **联系用户**：通过 Bot 发送消息（支持文字/图片/视频/位置）
4. **配送执行**：根据用户地址完成配送
5. **完成确认**：配送完成后在系统中确认

**权限明细**：
- 查看分配给自己的订单详情
- 与订单用户进行沟通
- 标记订单配送状态
- 发起地址异常申请
- Bot 转发消息：通过 Bot webhook 转发所有用户与配送员的消息，消息中携带 `order_id`，确保会话上下文；支持文本、图片、视频、位置，并使用 Telegram `file_id` 引用媒体，无需存储。

**异常处理**：
- 10分钟未接单：自动转派给下一位配送员
- 30分钟无人接单：升级至客服处理
- 地址错误：可发起"地址异常"申请

#### 详细配送管理系统实现

**智能分配算法**：

**配送员分配优先级策略**：
- 地区匹配：优先分配同地区的在线配送员
- 距离优先：按照配送员与取货地点的距离排序
- 在线时长：连续在线时间长的配送员优先
- 实时状态：只分配给当前在线且可接单的配送员

**智能算法特点**：
- 实时计算配送员可用性
- 动态调整分配权重
- 保证订单分配的公平性
- 提升整体配送效率

订单均衡：当日接单少的配送员优先分配
在线时长：连续在线时间长的优先分配

**配送状态实时追踪**：
```
订单状态追踪界面：
📦 【订单追踪】📦
━━━━━━━━━━━━━━━━━
🚚 订单号：VP240101001234
📍 配送地址：XX区XX街道XX号
👤 配送员：张师傅 
💬 联系配送员：[点击联系]
━━━━━━━━━━━━━━━━━
⏰ 配送进度：
✅ 14:30 订单支付成功
✅ 14:35 分配配送员  
✅ 14:40 配送员接单
🚛 14:45 配送员取货 (当前)
⏳ 预计 15:20 送达目的地
━━━━━━━━━━━━━━━━━
📱 实时位置：距离您2.3公里
🕐 预计到达：15-25分钟
━━━━━━━━━━━━━━━━━
[💬 联系配送员] [🚨 申报异常]
```

**地址异常处理流程**：
```
异常类型识别：
1. 地址不存在或无法找到
2. 地址与实际位置不符  
3. 客户临时更改地址
4. 配送区域超出服务范围

处理流程：
配送员发现异常 → 拍照记录现场 → 在系统中选择异常类型 → 
自动通知用户确认 → 用户确认新地址 → 系统计算额外费用 → 
用户同意后继续配送 → 完成配送

额外费用计算：
- 同区域地址修正：免费
- 跨区域配送：+10 USDT  
- 超出服务范围：+20 USDT或改为自提
- 多次地址变更：第3次起每次+5 USDT
```

**配送纠纷仲裁机制**：
```
纠纷类型及处理：

1. 配送延迟纠纷：
   - 超时2小时自动触发
   - 配送员需提供延迟原因（天气/交通/地址等）
   - 用户可选择：继续等待/改为自提/申请退款

2. 商品损坏纠纷：
   - 配送员需在取货时拍照记录商品状态
   - 送达时用户自行验货，发现问题立即拍照
   - 系统根据前后照片对比判定责任方
   - 责任方承担相应赔偿

3. 服务态度纠纷：
   - 用户可举报配送员服务态度问题
   - 需提供具体事实描述和证据
   - 客服在24小时内介入调查
   - 根据调查结果对配送员进行教育或处罚

仲裁原则：
- 客观证据优先（照片、录音、GPS轨迹）
- 用户体验导向，争议情况倾向用户
- 重大纠纷升级至管理员人工处理
```

### 5. 客服员（Customer Service）
**角色定义**：处理支付确认和用户问题

**工作职责**：
- **支付确认**：
  - 接收汇旺支付通知
  - 核实到账后确认订单
  - 处理支付异常问题
- **问题处理**：
  - 响应用户咨询
  - 处理配送纠纷
  - 协调订单异常
- **提现审核**：
  - 大额提现人工审核（>100 USDT 系统自动通知）
  - 确认转账完成
  - 通知用户到账

### 6. 会员用户（VIP User）
**角色定义**：通过付费或达标获得的高级用户

**获取方式**：
1. **直接购买**：使用 USDT 购买月度/永久会员
2. **积分兑换**：累积足够积分兑换会员资格
3. **购买达标**：购买次数达到设定值自动解锁
4. **抽奖获得**：通过积分抽奖获得临时/永久会员

**专属权益**：
- 查看会员专属商品
- 享受会员专属价格
- 专属客服通道优先响应
- 额外积分奖励倍率

**会员管理**：
- 到期前3天系统自动提醒续费
- 到期当天24:00准时失效
- 失效后立即恢复为普通用户权限

### 7. 普通用户（Regular User）
**角色定义**：所有进入 Bot 的基础用户

**自动识别**：用户点击 start 进入 Bot 即自动创建账户，无需注册

**基础权限**：
- 浏览非会员商品
- 下单购买
- 查看订单
- 参与推广活动
- 使用积分功能
- 联系客服

---

## 🔄 核心业务流程详解

### 1. 首次使用流程

```
用户点击 Bot 链接 → 自动识别 Telegram ID → 创建用户账户 → 显示欢迎语 → 展示活动公告 → 进入主菜单
```

**详细说明**：
- 无需任何注册步骤
- 系统自动获取用户 Telegram 信息
- 默认语言为中文
- 欢迎语和活动公告可在后台配置

### 2. 完整购买流程

#### 2.1 商品浏览路径

**路径A - 从"购买商品"进入**：
```
点击"🛒 购买商品" → 选择地区 → 显示该地区所有商品 → 选择商品查看详情
```

**路径B - 从"待购清单"进入**：
```
点击"📦 订单配送" → 选择"待购清单" → 直接显示商品列表（使用上次选择的地区）
```

**地区记忆机制**：
- 首次购买需选择国家和地区
- 系统自动记住用户选择
- 下次从"购买商品"进入只需选择地区（显示该国家下的地区列表）
- 从"待购清单"进入无需选择，直接使用记住的地区

#### 2.2 下单支付流程

```
选择商品 → 选择规格/数量 → 选择配送方式 → 填写配送信息 → 选择支付方式 → 创建订单 → 进入支付
```

**配送方式说明**：
- **自提**：仅支付商品金额，用户自行到指定地点取货
- **配送**：商品金额 + 20 USDT 配送费（配送费可后台配置）

**支付方式处理**：

1. **汇旺支付**：
   ```
   显示收款信息 → 用户转账 → 用户点击"支付完成" → 系统通知客服 → 客服确认到账 → 订单支付成功
   ```

2. **加密货币支付**（USDT/ETH）：
   ```
   系统基于商家提供的xpub生成唯一的订单收款地址 → 显示支付金额、收款地址及Gas Fee提醒 → 用户支付（需额外支付网络Gas Fee） → 系统通过监控xpub关联的所有地址，自动检测到账 → 自动确认 → 订单支付成功
   ```
   **核心机制**：采用HD钱包授权模式，商家提供扩展公钥（xpub），系统为每笔订单生成唯一子地址，既能实现自动收款确认，又能保障商家资金安全（私钥由商家掌控）。

#### 详细HD钱包技术实现

**地址生成算法设计**：

**BIP44标准派生路径规范**：
- USDT(TRC20)派生路径：基于TRX标准的地址生成
- USDT(ERC20)派生路径：基于ETH标准的地址生成  
- ETH派生路径：基于以太坊标准的地址生成

**地址生成流程**：
1. 商家配置主公钥(xpub)
2. 系统接收订单并分配唯一ID
3. 计算派生索引（订单ID取模确保范围）
4. 生成对应的唯一收款地址
5. 执行地址唯一性检查
6. 返回专属收款地址给用户

**区块链监控机制**：

**监控参数配置**：
- 监控频率：每30秒扫描新区块
- 监控深度：最新1000个区块（约30分钟内）
- 确认标准：
  * USDT(TRC20)：19个区块确认（约1分钟）
  * USDT(ERC20)：12个区块确认（约3分钟）
  * ETH：12个区块确认（约3分钟）

**监控流程设计**：
1. 实时获取最新区块高度
2. 扫描新增区块中的所有交易记录
3. 匹配交易收款地址与系统生成地址
4. 验证交易金额与订单金额匹配（±5%容差）
5. 达到确认要求后自动更新订单状态
6. 触发支付成功通知机制

**Gas费处理策略**：
用户端显示：
💰 商品金额：100 USDT
⛽ 网络费用：约5-15 USDT (实时估算)
💎 应付总额：100 USDT (商品) + Gas费(用户承担)

Gas费估算：
- TRC20: 固定约14 TRX（约1 USDT）
- ERC20: 动态估算，显示慢/标准/快三档
- ETH: 根据网络拥堵情况实时计算

用户提醒：
⚠️ 重要提醒：
1. 请额外支付网络Gas费用
2. Gas费不足可能导致转账失败
3. 转账金额请精确到小数点后6位
4. 建议使用官方钱包确保兼容性
```

**异常处理机制**：
```
支付异常类型及处理：

1. 多付情况：
   - 自动检测超额支付
   - 超额部分自动转入用户余额
   - 发送多付处理通知

2. 少付情况：
   - 检测到少付后暂停订单
   - 通知用户补足差额或申请退款
   - 7天内可补付，超时自动退款

3. 重复支付：
   - 检测同一地址多笔转账
   - 首笔作为订单支付，其余转入余额
   - 自动合并计算避免重复确认

4. 网络延迟：
   - 支付后2小时未确认显示"网络拥堵"
   - 提供交易哈希查询功能
   - 人工客服介入协助确认

5. 错误地址：
   - 用户转错地址无法自动确认
   - 提供申诉通道，需提供交易证明
   - 48小时内人工核实后手动确认
```

**支付超时处理**：
- 创建订单后30分钟未支付自动标记为"未支付"
- 未支付订单保留24小时，期间可"继续支付"
- 未支付订单24小时后物理删除订单数据
- 已支付订单12小时后物理删除订单数据
- 删除前自动通知超级管理员和对应管理员

### 3. 配送管理流程

#### 3.1 正常配送流程

```
订单支付成功 → 系统按配送员列表顺序分配 → 通知配送员 → 配送员10分钟内接单 → 
配送员联系用户 → 完成配送 → 配送员确认完成 → 订单完成
```

#### 3.2 异常处理机制

**无人接单处理**：
```
首次分配无响应(10分钟) → 自动转派下一位 → 循环尝试所有配送员 → 
30分钟仍无人接单 → 通知客服介入 → 客服可选择：手动分配/用户自提/订单退款
```

**地址异常处理**：
```
配送员发现地址错误 → 发起"地址异常"申请 → 用户收到通知 → 
用户确认新地址 → 评估是否产生额外费用 → 继续配送
```

**配送纠纷处理**：
```
用户/配送员发起申诉(12小时内) → 提交问题描述和证据 → 客服介入 → 
客服通过与双方沟通进行评判 → 24小时内给出裁决 → 通知处理结果
```

### 4. 商家入驻与管理流程

#### 4.1 简化入驻流程

**入驻要求（已简化）**：
- ✅ 无需营业执照
- ✅ 无需店铺名称（使用用户昵称）
- ✅ 地区选择（国家/地区或手动输入）
- ✅ 在线支付保证金和租金

**自动化入驻流程**：
```
会员商家入口 → 点击"商家入驻" → 选择国家/地区 → 
查看费用明细 → 确认支付 → Bot授权引导 → 自动开通完成
```

**技术实现特点**：
1. **地区选择界面** - 支持下拉选择或手动输入
2. **自动支付处理** - 使用管理员配置的收款地址，支持多种加密货币
3. **Bot授权流程** - 智能检测Business Account，一键深度链接授权
4. **自动后端开通** - 支付确认后webhook触发，无需人工审核

**支付结构**：
- 保证金：$1000等值加密货币（一次性，转入管理员收款地址）
- 租金：按地区定价（月付，转入管理员收款地址）
- 支付确认后即时开通，无等待期
- 支持币种：BTC、ETH、USDT、TRX等（管理员可配置）

#### 4.2 商品上架流程

```
商家添加商品 → 填写商品信息 → 设置价格/库存 → 提交审核 → 
管理员审核 → 通过则上架/驳回则修改
```

**商品信息要求**：
- 商品名称（必填）
- 商品描述（必填）
- 商品图片（最少1张，最多9张）
- 商品分类
- 商品规格（支持多规格）
- 价格设置（支持阶梯价）
- 库存数量
- 是否会员专属

#### 4.3 租金管理机制

```
每月到期前3天 → 系统自动发送续费提醒 → 商家可选择续费 → 
到期日未续费 → 自动冻结商品上架权限 → 保留7天补缴窗口 → 
补缴后自动恢复权限
```

### 5. 资金流转逻辑

#### 5.1 用户购买商品资金流

```
用户支付 → 资金直接进入由系统为本订单生成的、与商家xpub关联的唯一收款地址 → 订单完成 → 资金进入24小时结算锁定期 → 锁定期结束无纠纷 → 资金在商家端完全可用
```

**重要说明**：
- **资金安全**：用户付款通过HD钱包机制直接进入商家控制的地址，平台不触碰资金。
- **结算锁定期**：为保障用户权益，订单完成后的24小时内为“结算锁定期”。在此期间，用户可发起申诉。该锁定仅为逻辑状态，用于纠纷仲裁，资金物理上已在商家地址中。
- **独立配置**：商家仅需在后台配置一次钱包扩展公钥（xpub），无需为每笔交易配置地址。
- **管理员角色**：管理员不参与商品交易资金流转。

#### 5.2 软件使用权购买资金流

```
用户在任何管理员平台购买软件 → 支付到超级管理员收款地址 → 
超级管理员确认 → 开通管理员权限
```

**重要说明**：
- 软件销售收入归超级管理员所有
- 管理员无法配置软件销售收款方式
- 管理员后台没有软件销售入口

### 6. 提现管理流程

#### 6.1 小额提现（≤100 USDT）

```
用户/商家申请提现 → 填写提现地址 → 确认提现金额 → 
系统自动处理 → 管理员转账 → 标记已完成 → 通知到账
```

#### 6.2 大额提现（>100 USDT）

```
申请提现 → 系统通知管理员 → 管理员人工审核 → 
确认无异常 → 管理员转账 → 确认到账 → 通知用户
```

#### 6.3 超大额提现（>500 USDT）

```
申请提现 → 系统发送6位验证码到 Telegram → 用户输入验证码 → 
验证通过 → 通知管理员 → 后续流程同大额提现
```

---

## 📱 功能模块详细说明

### 前端主菜单（8个一级菜单）

#### 1. 🛒 购买商品

**功能描述**：商品浏览和购买的主入口

**操作流程**：
1. 点击进入后显示地区列表（仅显示用户所在国家的地区）
2. 选择地区后显示该地区所有在售商品
3. 商品列表显示：图片、名称、价格、库存状态
4. 点击商品查看详情：
   - 商品图片轮播
   - 详细描述
   - 规格选择
   - 阶梯价格表
   - 库存数量
5. 操作选项：
   - 立即购买
   - 加入待购清单
   - 返回列表

**特殊逻辑**：
- 会员商品仅对会员可见
- 库存不足时显示"预约到货通知"
- 限购商品显示剩余可购买数量

#### 2. 📦 订单配送

**功能描述**：订单管理中心

**子菜单结构**：
- **待支付订单**：
  - 显示剩余支付时间倒计时
  - 支持"继续支付"和"取消订单"
- **待配送订单**：
  - 显示配送员信息和联系按钮
  - 支持查看配送进度
- **待购清单**：
  - 显示加入的商品（自动使用记住的地区）
  - 支持批量下单
  - 商品失效自动标记
- **历史订单**：
  - 仅显示12小时内的已完成订单
  - 支持"再来一单"快捷复购
  - 支持申诉功能（12小时内）

#### 3. 💸 充值提现

**充值功能**：
- 支持币种：USDT、ETH
- 显示最低充值额度
- 生成专属充值地址
- 自动检测到账

**提现功能**：
- 显示可提现余额
- 最低提现额度限制（后台可配置）
- 提现地址管理（可保存常用地址）
- 提现记录查询

**安全机制**：
- 提现频率限制：每小时最多2次
- 大额提现验证：>500 USDT 需要验证码
- 异常检测：异常大额自动预警

#### 4. 🎉 推广活动

**推广返现**：
- **机制说明**：
  - 生成专属推广链接
  - 好友通过链接下单
  - 订单完成后返利5%纯利润
  - 返利金额进入推广余额
- **数据展示**：
  - 推广人数统计
  - 返利金额统计
  - 推广订单明细

#### 详细推广返现系统实现

**利润计算公式**：
```
纯利润 = 商品售价 - 商品成本 - 配送费 - 平台手续费(2%)
推广返现 = 纯利润 × 返现比例(5%)

示例：
商品售价：100 USDT
商品成本：60 USDT  
配送费：20 USDT
平台手续费：2 USDT (100 × 2%)
纯利润：100 - 60 - 20 - 2 = 18 USDT
推广返现：18 × 5% = 0.9 USDT
```

**多级返现体系**：
```
一级推荐（直接推荐）：5%纯利润
二级推荐（间接推荐）：2%纯利润
三级推荐（深度推荐）：1%纯利润

条件限制：
- 二级返现需一级推荐用户完成3单以上
- 三级返现需二级推荐用户完成5单以上
- 单笔返现上限：500 USDT
- 每月总返现上限：10000 USDT
```

**返现时机和资金来源**：
- **返现时机**：订单完成且过了24小时申诉期后自动结算
- **资金来源**：从商家纯利润中按比例扣除
- **资金流向**：推广返现 → 推广者余额 → 可提现/购物抵扣

**推广链接生成机制**：
```
链接格式：https://t.me/botname?start=ref_123456
参数说明：
- ref_：固定前缀
- 123456：推广者的user_id

首次访问流程：
1. 新用户点击推广链接
2. 启动Bot并传入start参数
3. 解析ref_参数绑定推荐关系
4. 显示特殊欢迎语："您通过 @推荐人 的推荐进入"
5. 完成绑定，推荐关系永久有效
```

**返现界面设计**：
```
💰 【推广返现】💰
━━━━━━━━━━━━━━━━━
🎯 我的推广链接：
https://t.me/vapebot?start=ref_123456
[📋 复制链接] [📤 分享链接]
━━━━━━━━━━━━━━━━━
📊 推广数据：
👥 累计推广：156人
💎 有效用户：89人 (下单≥1次)
💰 累计返现：234.56 USDT
📈 本月返现：45.78 USDT
━━━━━━━━━━━━━━━━━
🏆 推广排行榜：
🥇 @user****1234  350.50 USDT
🥈 @user****5678  298.30 USDT  
🥉 @user****9012  245.80 USDT
━━━━━━━━━━━━━━━━━
[💸 立即提现] [📋 返现明细]
```

**积分系统**：
- **获取方式**：
  - 下单获得（金额的10%转为积分）客单价200 USDT→20积分，500 USDT→50积分
  - 每日签到（基础10积分）= 1 USDT购买力
  - 连续签到奖励（7天+5积分，14天+10积分，30天+20积分）
  - 推广获得（每个有效用户25积分）= 2.5 USDT购买力
  - 抽奖参与（消耗100积分/次）= 10 USDT购买力
- **使用方式**：
  - 参与抽奖（100积分/次）
  - 兑换会员（500积分=月会员，等价交换）
  - 抵扣购物金额（1积分=0.1 USDT购买力）
- **价值体系**：
  - 积分获得：1 USDT = 1积分
  - 积分使用：1积分 = 0.1 USDT购买力
  - 有效期180天（按获得时间计算）
  - 到期前7天、3天、1天推送提醒
  - 过期自动清零，保留流水记录

#### 详细签到系统实现

**签到规则设计**：
- **刷新时间**：每日00:00（用户所在时区）自动刷新
- **签到窗口**：当日00:00-23:59，错过无法补签
- **连续计算**：中断后从第1天重新开始计算
- **时区处理**：根据用户地区设置确定本地时间

**签到奖励梯度**（基于1积分=0.1 USDT购买力）：
```
第1天：10积分 (=1 USDT购买力)
第2天：10积分 
第3天：10积分
第4天：10积分
第5天：10积分
第6天：10积分
第7天：10积分 + 额外5积分奖励 (连续7天奖励)
第8-13天：每天10积分
第14天：10积分 + 额外10积分奖励 (连续14天奖励)
第15-29天：每天10积分
第30天：10积分 + 额外20积分奖励 (连续30天大奖)
第31天及以后：每天10积分，每满30天重复第30天奖励
```

**连续签到里程碑奖励**：
- 连续7天：+5积分 (7天共获得75积分，=7.5 USDT购买力)
- 连续14天：+10积分 (14天共获得150积分，=15 USDT购买力)
- 连续30天：+20积分 (30天共获得320积分，=32 USDT购买力)
- 连续60天：+50积分 (60天共获得650积分，可兑换月会员+剩余)
- 连续100天：+100积分 + 7天会员体验
- 连续365天：+300积分 + 月度会员

**签到界面设计**：
```
📅 【每日签到】📅
━━━━━━━━━━━━━━━━━
🎯 今日奖励：10积分 (=1 USDT购买力)
⚡ 连续签到：6天
🔥 下次里程碑：第7天可获得15积分总奖励
💡 提醒：坚持签到50天可兑换月会员
━━━━━━━━━━━━━━━━━
📊 本月签到日历：
周一 周二 周三 周四 周五 周六 周日
 1✅  2✅  3✅  4✅  5✅  6✅  7⭐
 8   9   10  11  12  13  14⭐
15  16  17  18  19  20  21
22  23  24  25  26  27  28
29  30  31
━━━━━━━━━━━━━━━━━
🏆 签到里程碑进度：
📈 7天奖励: 6/7天 (还差1天，可获75积分)
📈 14天奖励: 6/14天 (还差8天，可获155积分)  
📈 30天奖励: 6/30天 (还差24天，可获320积分)
━━━━━━━━━━━━━━━━━
[✅ 立即签到] [📈 签到统计] [🎁 奖励预览]
```

**防刷机制**：
- 基于Telegram ID + 日期的唯一性校验
- 服务器时间为准，忽略客户端时间
- 签到状态实时同步，防止重复请求
- 异常签到行为监控和封禁机制

**重要说明**：
⚠️ **积分价值体系（基于新业务数据优化）**：
- 积分获得：1 USDT = 1积分
- 积分使用：1积分 = 0.1 USDT购买力
- 每日签到：10积分 = 1 USDT购买力（年化365 USDT购买力）
- 抽奖成本：100积分 = 10 USDT购买力（适合高客单价用户）
- 会员兑换：500积分 = 50 USDT购买力（等价交换，非惩罚性）
- 下单获得：客单价10%转积分（200 USDT→20积分，500 USDT→50积分）

💡 **基于80%周复购率的用户画像**：
- 典型用户月消费：200-500 USDT × 4周 × 80% = 640-1600 USDT
- 月获得积分：64-160积分 = 6.4-16 USDT购买力
- 签到补充：10积分/天 × 30天 = 300积分 = 30 USDT购买力
- 总月积分：364-460积分 = 36.4-46 USDT购买力

🎯 **用户路径设计**：
- 低消费用户（月640 USDT）：需4.1个月积分可兑换月会员
- 高消费用户（月1600 USDT）：需2.7个月积分可兑换月会员
- 配合购买达标：消费2000 USDT直接获得月会员
- 积分主要用于抽奖娱乐和小额抵扣

📊 **成本效益分析**：
- 利润率50%-200%，平均125%
- 用户年消费7680-19200 USDT，年利润9600-38400 USDT
- 年签到成本：365积分 = 36.5 USDT购买力
- 成本占利润比例：0.1%-0.38%，完全可控

**抽奖活动**：
- **奖品设置**：
  - 积分（10-1000分）
  - 临时会员（7天/30天）
  - 永久会员
  - 指定商品
  - 优惠券
- **参与限制**：
  - 消耗积分参与（可配置）
  - 频率限制：每分钟最多5次
  - 中奖公示：实时滚动显示

#### 详细抽奖系统实现

**抽奖算法设计**：
```javascript
**可配置权重抽奖算法设计**（匹配200-500 USDT客单价）：

**奖池配置系统**：
- **积分奖励类**：10积分(权重2500)、20积分(权重2000)、50积分(权重1500)、100积分(权重800)
- **实物奖励类**：5代烟弹×1(权重400)、6代烟弹×1(权重300)、5代烟弹×3(权重200)、6代烟弹×3(权重150)
- **会员权益类**：7天会员(权重100)、30天会员(权重40)、永久会员(权重5)
- **安慰奖项**：谢谢参与(权重2000)

**抽奖参数配置**：
- 每次抽奖消耗：100积分（=10 USDT购买力）
- 普通用户限制：每日最多10次
- VIP用户限制：每日最多20次
- 奖品开关：管理员可动态启用/禁用奖品

**动态概率计算**：
- 系统根据启用奖品动态计算总权重
- 实时计算每个奖品的中奖概率
- 支持概率百分比显示
- 管理员可查看实时概率分布
```

**保底机制**（考虑抽奖成本100积分=10 USDT购买力）：
- 连续10次未中实物奖品必中5代烟弹×1
- 连续20次未中实物奖品必中6代烟弹×1  
- 连续30次未中会员必中7天会员
- 每日首次抽奖保底10积分（保护用户投入）

**抽奖界面实现**（Telegram Bot适配）：
```
🎲 【幸运抽奖】🎲
━━━━━━━━━━━━━━━━━
🎁 奖品池：
💎 永久会员 (0.05%)
⭐ 30天会员 (0.4%)  
🌟 7天会员 (1%)
� 6代烟弹×3 (1.5%)
🔥 5代烟弹×3 (2%)
💨 6代烟弹×1 (3%)
⚡ 5代烟弹×1 (4%)
💰 500积分 (8%)
✨ 200积分 (15%)
🎯 100积分 (20%)
🌟 50积分 (25%)
💔 谢谢参与 (25%)
━━━━━━━━━━━━━━━━━
💎 您的积分：15800 (≈1580 USDT购买力)
🎮 消耗积分：500/次 (≈50 USDT)
🍀 今日已抽：3/10次
━━━━━━━━━━━━━━━━━
[🎲 开始抽奖] [📊 中奖记录] [⚙️ 奖池配置]
```

**奖池管理系统**（管理员功能）：
```
⚙️ 【奖池配置】⚙️
━━━━━━━━━━━━━━━━━
🎁 奖品管理：
✅ 5积分 (权重3000) [编辑] [禁用]
✅ 10积分 (权重2500) [编辑] [禁用]
✅ 20积分 (权重1500) [编辑] [禁用]
✅ 50积分 (权重800) [编辑] [禁用]
✅ 5代烟弹×1 (权重400) [编辑] [禁用]
✅ 6代烟弹×1 (权重300) [编辑] [禁用]
✅ 5代烟弹×3 (权重200) [编辑] [禁用]
✅ 6代烟弹×3 (权重150) [编辑] [禁用]
✅ 7天会员 (权重100) [编辑] [禁用]
✅ 30天会员 (权重40) [编辑] [禁用]
✅ 永久会员 (权重5) [编辑] [禁用]
✅ 谢谢参与 (权重3000) [编辑] [禁用]
━━━━━━━━━━━━━━━━━
💰 抽奖成本：100积分/次 (=10 USDT购买力)
📊 每日限制：普通10次 VIP20次
[➕ 新增奖品] [💾 保存配置] [📊 概率预览]
```

**中奖公示系统**：
- 实时滚动显示最近50条中奖记录
- 格式：`🎉 用户****1234 获得 6代烟弹×1 (5分钟前)`
- 实物奖品中奖全屏弹窗庆祝动效
- 会员奖品特殊标识和庆祝效果
- 自动过滤谢谢参与，只显示实际奖品
- 大奖公示（永久会员、烟弹×3）置顶显示

**实物奖品发放流程**：
```
中奖确认 → 自动生成兑换码 → 用户收到兑换通知 → 
选择收货地址 → 系统生成配送订单 → 配送员配送 → 确认收货完成
```

**风险控制**：
- 单用户每日最大消耗上限：500积分（=500 USDT，匹配客单价群体）
- 连续大额消费预警机制（超过300积分/日触发）
- 异常中奖行为监控和大奖审核机制
- 实物奖品库存自动检测，库存不足自动禁用对应奖品
- 会员兑换冷却时间：同一用户7天内只能兑换1次会员

#### 5. 👥 会员商家

**会员中心**：
- 显示会员等级和到期时间
- 会员权益说明
- 续费入口
- 会员专属商品推荐

**成为会员**：
- **购买会员**：
  - 月度会员（价格可配置）
  - 半年会员（价格可配置）
  - 永久会员（价格可配置）
- **积分兑换**：显示所需积分
- **购买达标**：显示进度条

#### 详细会员体系实现

**会员定价策略**：
```
月度会员：50 USDT（原价）
半年会员：250 USDT（节省50 USDT，8.3折）
永久会员：800 USDT（节省1200 USDT，4折）

积分兑换价格（等价交换原则）：
7天体验会员：150积分 (=15 USDT购买力，优惠价)
月度会员：500积分 (=50 USDT购买力，等价交换)
半年会员：2400积分 (=240 USDT购买力，等价交换)
永久会员：不支持积分兑换（保持稀缺性，鼓励现金购买）

购买达标规则（匹配200-500 USDT客单价）：
消费满200 USDT：自动获得7天体验会员（1-3单）
消费满2000 USDT：自动升级月度会员（4-10单）
消费满10000 USDT：自动升级半年会员（20-50单）
累计购买100单：自动获得永久会员（考虑80%周复购率特征）
```

**会员专属权益详细**：
```
✨ 基础权益：
- 查看会员专属商品（约占总商品80%）
- 所有商品享受9折优惠
- 专属客服通道，2分钟内响应

🎁 进阶权益：
- 每月专属优惠券（满100减20，1张）
- 优先配送权（会员订单优先分配）
- 新品优先购买权（限量商品提前24小时开放）

💎 顶级权益（永久会员）：
- 终身享受9折优惠
- 专属会员商品（限量版、新品首发）
- VIP客服专线（1分钟内响应）
- 年度实物礼品邮寄
```

**会员界面设计**：
```
👑 【会员中心】👑
━━━━━━━━━━━━━━━━━
💎 当前等级：月度会员
⏰ 到期时间：2024-01-15 23:59
🎯 续费优惠：半年会员7折续费
━━━━━━━━━━━━━━━━━
✨ 专属权益：
🛒 会员专属商品
🎧 专属客服通道
🚀 优先配送权
━━━━━━━━━━━━━━━━━
🎁 本月福利：
💰 专属优惠券：满100减5
🎪 新品内测：电子烟Pro版
━━━━━━━━━━━━━━━━━
[💳 续费会员] [🎁 领取福利] 
```

**会员升级和续费机制**：
- 自动升级：达到条件后系统自动推送升级通知
- 续费优惠：到期前7天享受续费折扣
- 降级保护：会员过期后保留7天缓冲期，期间可原价续费
- 福利保留：降级后已获得的优惠券等福利仍然有效


#### 6. 💬 客服中心

**功能结构**：
- **常见问题**：FAQ 列表
- **在线客服**：
  - 自动分配在线客服
  - 支持发送文字/图片
  - 历史对话记录
- **订单客服**：针对特定订单的问题
- **投诉建议**：提交投诉和建议

#### 7. ⚙️ 帮助设置

**个人信息**：
- Telegram ID（不可修改）
- 昵称显示
- 账户余额
- 积分余额
- 会员状态

**地区设置**：
- 当前国家（可切换）
- 常用地区（购买时可快速选择）

**系统设置**：
- 消息通知开关
- 默认配送方式
- 默认支付方式

**使用帮助**：
- 新手教程
- 视频指南
- 联系我们

#### 8. 🌐 Language

**支持语言**：
- 🇨🇳 中文（默认）
- 🇺🇸 English
- 其他语言（可扩展）

**切换机制**：
- 点击立即切换
- 全局生效
- 记住用户选择

### 后端主菜单（8个一级菜单）

#### 1. 🌍 地区管理

**国家管理**：
- **支持国家列表**（硬性数据，不可更改）：
  - 🇹🇭 泰国 (Thailand)
  - 🇻🇳 越南 (Vietnam)  
  - 🇱🇦 老挝 (Laos)
  - 🇲🇲 缅甸 (Myanmar)
  - 🇦🇪 迪拜 (Dubai)
  - 🇲🇾 马来西亚 (Malaysia)
  - 🇸🇬 新加坡 (Singapore)
  - 🇰🇷 韩国 (South Korea)
- **功能列表**：
  - 添加国家（名称、代码、图标/Emoji、时区）
  - 编辑国家信息
  - 启用/禁用国家
  - 删除国家（需确认无关联数据）
- **批量操作**：
  - 导入国家列表（CSV格式）
  - 导出国家数据

**地区管理**：
- **功能列表**：
  - 按国家添加地区
  - 设置地区名称（支持多语言）
  - 配置地区配送员列表
  - 设置地区营业时间
  - 启用/禁用地区
- **配送员分配**：
  - 添加配送员 Telegram ID
  - 设置分配优先级
  - 查看配送员工作状态

#### 2. 🏬 商品管理

**商品分类**：
- 创建商品分类树
- 设置分类图标
- 分类排序

**商品维护**：
- **基础信息**：
  - 商品名称（必填，支持多语言）
  - 商品描述（支持富文本）
  - 商品图片（1-9张，支持排序）
  - 商品分类
  - 商品标签
- **价格库存**：
  - 单规格/多规格切换
  - 阶梯价格设置（购买数量-对应价格）
  - 库存数量设置
  - 库存预警阈值
  - 成本价设置（用于计算利润）
- **销售设置**：
  - 上架/下架状态
  - 限购数量（每用户）
  - 会员专属开关
  - 推荐位设置

**商品审核**（针对商家商品）：
- 待审核列表
- 快速预览功能
- 通过/驳回（需填写理由）
- 审核历史记录

**促销管理**：
- **限时特价**：
  - 设置特价时间段
  - 特价折扣或固定价格
  - 自动开始/结束
- **限量抢购**：
  - 设置抢购数量
  - 抢购时间
  - 每人限购数量

#### 3. 🎊 活动管理

**推广配置**：
- 基础返利比例设置（默认5%）
- 特殊商品返利比例
- 推广等级和阶梯返利
- 推广链接有效期

**积分规则**：
- **获取规则**：
  - 购买返积分比例
  - 签到积分设置
  - 连续签到奖励
  - 特殊活动积分
- **使用规则**：
  - 积分抵现比例
  - 兑换项目设置
  - 积分有效期

**抽奖配置**：
- **奖池设置**：
  - 添加奖品类型和数量
  - 设置中奖概率
  - 库存管理
- **规则设置**：
  - 单次消耗积分
  - 每日抽奖次数限制
  - 保底机制设置

**活动公告**：
- 创建活动公告
- 设置展示时间
- 目标用户群体
- 多语言版本

#### 4. 🏦 资金管理

**收款配置**：
- **管理员收款设置**：
  - 商家入驻费收款地址（BTC、ETH、USDT TRC20/ERC20、TRX等）
  - 支持多币种配置，管理员可灵活设置
  - 每种币种可配置专用收款地址
  - 收款地址优先级设置（推荐币种）
- **支付参数**：
  - 支付超时时间（默认30分钟）
  - 最小支付金额（按币种设置）
  - 实时汇率接口配置
  - Gas费预估与提醒

**商家订单收款**：
- 商家提供钱包扩展公钥（xpub）
- 系统为每笔订单生成唯一收款地址
- 自动监控到账状态
- 24小时结算锁定期后释放资金

**提现管理**：
- **待处理提现**：
  - 显示金额和收款地址
  - 用户历史记录
  - 一键批准/拒绝
  - 备注功能
- **提现设置**：
  - 最低提现额度
  - 提现手续费
  - 每日提现限额

**财务报表**：
- **实时数据**：
  - 今日销售额
  - 今日订单数
  - 今日新用户
  - 实时交易流水
- **统计报表**：
  - 按时间段统计
  - 按商品统计
  - 按地区统计
  - 利润分析报表

**商家结算**：
- 商家余额查询
- 租金收取记录
- 保证金管理
- 结算历史

#### 5. 🛡️ 权限管理

**角色管理**：
- 查看所有角色列表
- 角色权限明细
- 添加自定义角色（预留）

**管理员管理**（仅超级管理员可见）：
- **Token 审核**：
  - 待审核 Token 列表
  - 自动格式验证结果
  - 人工审核通过/拒绝
  - 审核历史记录
- **管理员列表**：
  - 查看所有管理员
  - 使用权到期时间
  - 续费提醒设置
  - 权限冻结/解冻

**商家管理**：
- 商家申请审核
- 商家列表和状态
- 保证金/租金查看
- 权限冻结/解冻

**员工管理**：
- 配送员列表和分配
- 客服员列表和状态
- 工作量统计
- 权限调整

**黑名单管理**：
- 添加黑名单（输入 Telegram ID）
- 黑名单列表
- 拦截记录（显示尝试访问）
- 移除黑名单

#### 6. 📈 数据管理

**实时看板**：
- **核心指标**：
  - GMV（商品交易总额）
  - 订单量和客单价
  - 活跃用户数（DAU/MAU）
  - 新增用户数
- **排行榜**：
  - 商品销量 TOP 10
  - 商家销售额排名
  - 用户消费排名
  - 地区销售排名

**数据分析**：
- **用户分析**：
  - 用户画像（地区、消费等级）
  - 留存率分析
  - 复购率统计
  - 生命周期价值
- **商品分析**：
  - 动销率统计
  - 库存周转率
  - 商品关联分析
  - 价格敏感度分析
- **运营分析**：
  - 转化漏斗分析
  - 支付成功率
  - 配送及时率
  - 客服响应时间

**数据导出**：
- 选择数据类型
- 选择时间范围
- 选择导出格式（Excel/CSV）
- 定时邮件发送（如配置邮箱）

#### 7. 📣 消息管理

**群发消息**：
- **发送对象**：
  - 所有用户
  - 按角色筛选（普通/会员）
  - 按地区筛选
  - 按标签筛选
- **消息类型**：
  - 文本消息
  - 图文消息
  - 视频消息
- **发送设置**：
  - 立即发送
  - 定时发送
  - 分批发送（避免限流）

**自动消息**：
- 欢迎消息设置
- 订单状态变更通知
- 积分到期提醒
- 会员到期提醒

**消息模板**：
- 创建消息模板
- 变量替换设置
- 多语言版本
- 快速调用

#### 详细消息通知系统实现

**智能消息路由引擎**：
```javascript
// 消息优先级和路由规则
const messageRouting = {
  // 消息优先级定义
  priority: {
    emergency: 1,    // 紧急：系统故障、安全警告
    high: 2,         // 高：支付确认、订单异常
    normal: 3,       // 普通：订单状态、活动通知
    low: 4           // 低：营销推广、功能更新
  },
  
  // 发送策略
  strategies: {
    immediate: {     // 立即发送
      maxRetries: 3,
      retryInterval: 30,  // 30秒
      timeout: 300        // 5分钟超时
    },
    
    scheduled: {     // 定时发送
      batchSize: 100,     // 每批100条
      interval: 60,       // 1分钟间隔
      maxDaily: 10000     // 每日上限
    },
    
    throttled: {     // 频率限制
      userLimit: 10,      // 用户每小时最多10条
      globalLimit: 1000   // 全局每分钟最多1000条
    }
  }
};
```

**消息模板引擎设计**：

**模板结构设计**：
- **多语言支持**：中文(zh)和英文(en)模板并存
- **变量系统**：支持动态变量替换（订单号、金额、时间等）
- **优先级分类**：高优先级(high)、普通优先级(normal)、低优先级(low)
- **多渠道支持**：Telegram消息、通知等
- **条件触发**：基于用户类型、订单金额、支付状态等条件

**模板类型示例**：

**订单支付成功模板**：
- 中文模板：包含订单号、金额、预计送达时间
- 英文模板：对应的英文版本
- 触发条件：支付状态为已支付，订单金额大于0
- 推送渠道：Telegram + 短信

**会员到期提醒模板**：
- 中文模板：包含会员类型、到期日期、续费优惠
- 英文模板：对应的英文版本
- 定时推送：到期前7天、3天、1天的晚上8点
- 推送渠道：仅Telegram

**变量替换引擎功能**：
- 支持模板变量自动替换
- 验证变量完整性
- 处理缺失变量的默认值
- 支持条件判断和循环结构
  
  let message = template[language];
  
  // 变量替换
  template.variables.forEach(variable => {
    const placeholder = `{${variable}}`;
    const value = data[variable] || '';
    message = message.replace(new RegExp(placeholder, 'g'), value);
  });
  
  // 条件判断
  if (template.conditions) {
    const conditionsMet = evaluateConditions(template.conditions, data);
    if (!conditionsMet) return null;
  }
  
  return {
    message,
    priority: template.priority,
    channels: template.channels
  };
}
```

**用户通知偏好管理**：
```javascript
// 用户通知设置
const userNotificationSettings = {
  userId: 123456,
  preferences: {
    // 通知类型开关
    orderUpdates: true,      // 订单更新
    paymentNotices: true,    // 支付通知
    promotions: false,       // 营销活动
    systemAlerts: true,      // 系统通知
    
    // 接收时间设置
    quietHours: {
      enabled: true,
      start: '22:00',
**用户通知偏好设置**：
- 免打扰时间段：用户可设置晚上22:00到早上08:00的免打扰时间
- 接收频率限制：每小时最多5条消息，每日最多20条消息
- 渠道偏好配置：
  * Telegram：默认开启

**通知频率控制算法设计**：

**控制策略**：
- **免打扰时间检查**：在用户设置的免打扰时间段内不发送非紧急通知
- **频率限制检查**：
  * 小时级限制：检查最近1小时内的消息数量
  * 日级限制：检查当日累计消息数量
- **消息类型分级**：紧急消息可突破部分限制

**检查流程**：
1. 获取用户个性化通知设置
2. 检查当前时间是否在免打扰时间段
3. 统计用户最近1小时收到的消息数量
4. 统计用户当日累计收到的消息数量
5. 根据检查结果决定是否允许发送
6. 返回检查结果和拒绝原因（如适用）
}
```

**消息发送失败处理机制**：

**消息重试策略设计**：
- **指数退避策略**：
  * 重试间隔：1秒、2秒、4秒、8秒...按指数增长
  * 最大重试：5次
  * 最大延迟：5分钟
- **固定间隔策略**：
  * 重试间隔：每30秒重试一次
  * 最大重试：3次
  * 最大延迟：90秒

**失败处理流程设计**：
1. **错误分析**：根据错误类型制定处理策略
2. **分类处理**：
   * 用户屏蔽Bot：标记用户为不可达状态
   * 频率限制：延长重试间隔，使用指数退避
   * 网络错误：使用固定间隔快速重试
   * 用户不存在：标记用户为无效状态
   * 其他错误：使用默认重试策略
3. **重试管理**：
   * 重试次数限制：最多3次重试
   * 失败队列：重试用尽后转入失败队列
   * 日志记录：完整的失败原因和重试记录

**离线消息缓存机制**：
- **缓存策略**：
  * 最大缓存时间：72小时
  * 每用户最大缓存：100条消息
  * 缓存清理：自动移除过期和超量消息
- **缓存管理**：
  * 消息入队：检查缓存限制和用户状态
  * 消息出队：用户上线时批量推送缓存消息
  * 优先级处理：重要消息优先推送
      ...message,
      cachedAt: Date.now(),
      priority: message.priority || 'normal'
    });
    
    // 按优先级排序
    userCache.sort((a, b) => a.priority - b.priority);
  },
  
  // 发送缓存消息
  flushCachedMessages: async (userId) => {
    const userCache = getUserCache(userId);
**离线消息推送流程**：
1. 检查用户缓存消息队列
2. 过滤过期消息（超过最大缓存时间）
3. 批量推送有效消息：
   - 逐条发送消息
   - 间隔1秒避免频率限制
   - 记录发送失败的消息
4. 清空用户消息缓存

**缓存管理策略**：
- 有效性检查：自动过滤过期消息
- 发送控制：防止频率限制的发送间隔
- 错误处理：失败消息的记录和处理
- 缓存清理：成功推送后清空缓存
```

#### 8. ⚙️ 系统管理

**基础配置**：
- **平台参数**：
  - 配送费金额（默认 20 USDT）
  - 最低提现额度
  - 订单自动清理时间
  - 积分有效期
- **业务规则**：
  - 库存预警阈值
  - 支付超时时间
  - 退款审核规则
- **风控规则设置**：
  - **用户风控**：可配置下单频率限制、单日下单次数上限、单日累计下单金额上限、新用户首次下单金额上限。
  - **商家风控**：可配置单日收款上限、提现频率限制、单次/单日提现额度限制。
  - **汇率管理**：所有加密货币对法币（如USDT对USD）的汇率，由管理员在后台手动配置和更新。

#### 详细风控规则引擎设计

**用户风控规则详细配置**：
```javascript
// 用户风控配置示例
const userRiskRules = {
  // 新用户限制（注册7天内）
  newUser: {
    maxFirstOrder: 100,        // 首单最高金额100 USDT
    maxDailyOrders: 3,         // 每日最多3单
    maxDailyAmount: 300,       // 每日限额300 USDT
    requiredPhoneVerify: true  // 必须手机验证
  },
  
  // 普通用户限制
  normalUser: {
    maxOrdersPerHour: 5,       // 每小时最多5单
    maxDailyOrders: 20,        // 每日最多20单
    maxDailyAmount: 2000,      // 每日限额2000 USDT
    maxSingleOrder: 500        // 单笔最高500 USDT
  },
  
  // 异常行为检测
  abnormalDetection: {
    rapidOrders: {             // 快速下单检测
      timeWindow: 300,         // 5分钟内
      maxOrders: 10,           // 超过10单触发
      action: 'freeze_1hour'   // 冻结1小时
    },
    
    duplicateAddress: {        // 重复地址检测
      timeWindow: 86400,       // 24小时内
      maxSameAddress: 5,       // 同地址超过5单
      action: 'manual_review'  // 人工审核
    },
    
    suspiciousAmount: {        // 可疑金额检测
      pattern: [99.99, 100.01, 188.88], // 特殊金额
      action: 'delay_payment'  // 延迟支付确认
    }
  }
};
```

**商家风控规则详细配置**：
```javascript
const merchantRiskRules = {
  // 收款限制
  dailyReceiptLimit: {
    newMerchant: 5000,         // 新商家日收款限额5000 USDT
    normalMerchant: 20000,     // 普通商家20000 USDT
    vipMerchant: 50000         // VIP商家50000 USDT
  },
  
  // 提现限制
  withdrawalRules: {
    maxPerTransaction: 10000,   // 单笔最高10000 USDT
    maxDailyAmount: 30000,      // 每日最高30000 USDT
    maxFrequency: 5,            // 每日最多5次
    cooldown: 3600              // 提现间隔1小时
  },
  
  // 异常监控
  suspiciousActivity: {
    rapidWithdrawal: {          // 快速提现检测
      timeWindow: 3600,         // 1小时内
      maxAmount: 20000,         // 超过20000 USDT
      action: 'require_approval' // 需要审批
    },
    
    priceManipulation: {        // 价格操纵检测
      priceIncrease: 0.5,       // 价格涨幅超过50%
      timeWindow: 3600,         // 1小时内
      action: 'price_lock'      // 锁定价格
    }
  }
};
```

**智能风控算法实现**：
**用户风险评分算法设计**：

**风险评分维度**：
- **账户年龄评分（30%权重）**：
  * 新注册账户（7天内）：高风险（30分）
  * 短期账户（30天内）：中风险（15分）
  * 长期账户（30天以上）：无风险（0分）

- **交易历史评分（25%权重）**：
  * 新用户（订单数<5）：高风险（25分）
  * 少量交易（订单数<20）：中风险（10分）
  * 活跃用户（订单数≥20）：无风险（0分）

- **地址异常评分（20%权重）**：
  * 地址风险检查结果乘以20%权重
  * 包含异常关键词、格式异常等

- **支付方式评分（15%权重）**：
  * 加密货币支付：中风险（15分）
  * 其他支付方式：低风险（5分）

- **订单金额评分（10%权重）**：
  * 大额订单（>1000 USDT）：风险（10分）
  * 普通金额：无风险（0分）

**风险处理策略**：
- 极高风险（≥80分）：直接拒绝订单
- 高风险（≥60分）：转入人工审核队列
- 中风险（≥40分）：延迟确认处理
- 低风险（≥20分）：加强监控记录
- 正常（<20分）：按正常流程处理

**监控告警维度设计**：

**实时指标监控**：
- 下单频率异常：超过平均值3倍时触发告警
- 支付成功率异常：低于80%时触发告警
- 退款率异常：超过20%时触发告警
- 配送超时率异常：超过30%时触发告警

**自动告警规则**：
- 单用户异常：1小时内下单超过10次
- 商家异常：1小时内收款超过50000 USDT
- 系统异常：支付成功率低于70%
- 配送异常：配送员接单率低于50%

**告警通知方式**：
- Telegram消息推送：即时通知
- Webhook推送：对接第三方监控系统

**自动处理机制**：
- 风险用户：自动限制交易功能
- 异常订单：自动标记为待审核
- 系统异常：自动切换备用节点
- 数据库异常：自动触发数据备份

**监控告警**：
- **系统监控**：
  - 服务器状态
  - 数据库性能
  - API 响应时间
  - 错误率统计
- **业务告警**：
  - 大额交易提醒
  - 库存不足预警
  - 异常登录检测
  - 恶意行为识别

**日志管理**：
- **操作日志**：
  - 用户操作记录
  - 管理员操作记录
  - 敏感操作审计
- **系统日志**：
  - 错误日志
  - 支付日志
  - 接口调用日志
- **日志查询**：
  - 按时间查询
  - 按用户查询
  - 按操作类型查询
  - 日志导出功能

**备份恢复**：
- 自动备份配置
- 手动备份触发
- 备份文件管理
- 紧急恢复功能（2小时内数据可恢复）

---

## 💾 数据库设计

### PostgreSQL 16+ 数据库结构设计

#### 核心数据库特性配置
```sql
-- 启用PostgreSQL 16+特性
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
**PostgreSQL扩展和时区配置**：
- btree_gin扩展：支持复合索引优化
- 时区设置：统一使用UTC时区

#### 1. 用户表 (users) - 增强版

**用户表结构设计**：
- **主键和唯一标识**：
  * 自增主键ID
  * Telegram用户ID（唯一约束）
- **基本信息字段**：
  * 用户名、名字、姓氏
  * 语言偏好（默认中文）
- **地理和关联信息**：
  * 国家ID、地区ID
  * 推荐人ID（支持推荐体系）
- **财务数据字段**：
  * USDT余额（20位精度，8位小数）
  * 积分余额
- **会员系统字段**：
  * 会员类型（普通、月度、永久）
  * 会员过期时间
- **统计信息字段**：
  * 总订单数、总消费金额
  * 最后活跃时间
- **安全相关字段**：
  * 设备指纹
  * 黑名单标记
- **系统字段**：
  * 创建时间、更新时间
  * JSONB元数据（扩展信息）
  * 全文搜索向量（自动生成）

**数据库索引设计**：
- 地区索引：支持按国家和地区快速查询用户
- 推荐人索引：支持推荐关系链查询
- 会员索引：支持会员用户的快速筛选
- 元数据GIN索引：支持JSONB字段的高效查询
- 搜索向量索引：支持全文搜索功能
- 活跃用户索引：支持按活跃度排序查询

**自动触发器设计**：
- 时间戳自动更新：用户信息更新时自动更新修改时间
- 统计数据维护：自动维护用户相关的统计信息

**用户活跃度统计**：
- 日活跃用户统计：按天统计活跃用户数量
- 付费用户统计：统计高级会员用户数量
- 30天滚动统计：保持最近30天的活跃度数据
- 物化视图优化：提升统计查询性能

#### 2. 角色权限表 (user_roles) - 增强版

**权限枚举类型设计**：
- 角色类型：超级管理员、平台管理员、商家、配送员、客服
- 角色状态：激活、冻结、过期

**权限表字段设计**：
- 用户关联：关联到具体用户
- 角色类型：定义用户的权限级别
- 管理员ID：记录权限分配者
- 商家ID：商家角色专用字段
- 权限配置：JSONB格式存储详细权限
- 过期时间：支持临时权限设置
- 状态管理：支持权限的激活/冻结

**索引优化策略**：
- 管理员关联索引：快速查找某管理员分配的权限
- 过期时间索引：支持权限到期检查
- 权限配置GIN索引：支持复杂权限查询

**自动权限管理功能**：
- 过期权限自动清理：定期将过期权限状态更新为已过期
- 权限有效性检查：确保系统中权限状态的准确性
- 自动时间戳更新：权限信息修改时自动更新修改时间

#### 3. 商家表 (merchants) - 增强版

**商家状态枚举设计**：
- 商家状态：待审核、已激活、已冻结、已退出

**商家表字段设计**：
- **基础信息**：商家ID、用户关联、管理员关联、经营地区
- **费用管理**：
  * 保证金金额和支付时间
  * 月租金和到期日期
  * 上次缴租时间记录
- **经营数据**：
  * 总销售额统计
  * 总订单数统计
- **配置信息**：
  * 收款钱包配置（JSONB格式）
- **状态管理**：商家状态、创建时间、更新时间

**商家表约束设计**：
- 同一管理员下每个地区只能有一个商家
- 确保地区商家的唯一性

**商家表索引设计**：
- 管理员地区索引：支持按管理员和地区查询商家
- 租金到期索引：支持查询租金即将到期的活跃商家
- 钱包配置GIN索引：支持钱包信息的复杂查询
- 营业执照GIN索引：支持执照信息的检索

**商家销售统计自动化**：
- 订单完成触发器：自动更新商家的订单总数和销售总额
- 实时统计更新：确保商家数据的实时性
- 性能优化：使用触发器避免频繁查询统计

**自动时间戳更新**：
- 商家信息修改时自动更新修改时间
- 保持数据变更的可追溯性

#### 4. 商品表 (products) - 增强版

**商品状态枚举设计**：
- 商品状态：待审核、已上架、已下架
- 审核状态：待审核、已通过、已拒绝

**商品表字段设计**：
- 商家关联：支持商家商品和管理员商品
- 管理员关联：记录商品所属管理员
- SKU编码：唯一商品标识
- 多语言支持：名称和描述支持中英文
- 图片管理：JSONB数组存储多张商品图片
- 规格配置：灵活的规格信息存储
- 价格体系：支持阶梯价格配置
- 库存管理：包含库存数量和预警值
- 销量统计：自动统计商品销量
- 会员专属：支持会员专属商品设置
- 限购控制：支持单用户限购数量
- 地区限制：支持地区销售限制
- 审核流程：完整的商品审核机制
**商品搜索向量设计**：
- 多语言搜索：支持中英文商品名称和描述搜索
- SKU搜索：包含商品编码的搜索支持
- 自动生成：使用PostgreSQL的generated列自动维护

**商品表索引优化设计**：
- 商家索引：按商家查询商品（仅商家商品）
- 管理员索引：按管理员查询所有商品
- 状态索引：按商品状态和审核状态查询
- 分类索引：按商品分类查询
- 库存预警索引：查询库存不足的商品
- 会员专属索引：查询会员专属商品
- 搜索向量GIN索引：全文搜索优化
- 商品名称GIN索引：商品名称模糊查询
- 地区限制GIN索引：按销售地区查询
- 规格GIN索引：按商品规格查询

**库存预警触发器设计**：
- 触发条件：库存降至预警值以下时触发
- 预警记录：自动创建库存预警记录
- 库存级别：标记为低库存状态
- 时间戳：记录预警触发时间

**自动时间戳更新**：
- 商品信息修改时自动更新修改时间
- 保持数据变更的可追溯性
    
    INDEX idx_merchant (merchant_id),
    INDEX idx_category (category_id),
    INDEX idx_status (status, audit_status),
**商品表索引设计**：
- 库存索引：支持库存量和预警值的快速查询

#### 5. 订单表 (orders)

**订单表字段设计**：
- **基础信息**：订单号、用户ID、商家ID、管理员ID、地区ID
- **商品信息快照**：JSON格式存储订单商品明细（产品ID、名称、价格、数量）
- **金额计算**：商品总额、配送费、总金额分别记录
- **配送管理**：
  * 配送方式：自提或配送
  * 配送地址和联系电话
  * 配送员分配和时间节点记录
- **支付系统**：
  * 支付方式：汇旺、USDT、ETH
  * 收款地址和支付金额（支持小数点8位精度）
  * 交易哈希和支付状态追踪
- **状态管理**：
  * 订单状态：待支付、待配送、配送中、已完成、已取消
  * 时间节点：支付时间、完成时间、自动删除时间
- **业务数据**：
  * 利润计算：售价减去成本的利润金额
  * 推广返利：推荐人获得的返利金额
  * 积分奖励：用户获得的积分数量
  * 备注信息：订单相关备注

**订单表索引优化**：
- 用户索引：支持用户订单查询
- 商家索引：支持商家订单管理
- 状态索引：支持按订单状态和支付状态查询
- 删除时间索引：支持自动删除任务
- 配送员索引：支持配送员订单查询

#### 6. 积分流水表 (point_transactions)
#### 6. 积分流水表 (point_transactions)

**积分流水表字段设计**：
- **基础信息**：流水ID、用户ID、积分变动类型
- **积分变动**：变动金额（正数获得，负数消耗）、变动后余额
- **关联信息**：关联订单ID、变动说明
- **时效管理**：积分过期时间、创建时间
- **索引优化**：用户索引、过期时间索引、类型索引

**积分类型说明**：
- 订单积分：完成订单获得
- 签到积分：每日签到奖励
- 推荐积分：推荐新用户奖励
- 抽奖积分：抽奖活动消耗
- 兑换积分：积分商城兑换
- 过期积分：积分到期扣除

#### 7. 消息记录表 (messages)

**消息记录表字段设计**：
- **用户信息**：发送者ID、接收者ID
- **消息内容**：消息类型（文本、图片、视频、位置）、消息内容、文件ID
- **关联信息**：关联订单ID（如适用）
- **状态管理**：已读状态、消息状态（已发送、已送达、发送失败）
- **重试机制**：重试次数记录
- **时间戳**：创建时间

**消息表索引设计**：
- 用户索引：支持按发送者和接收者查询消息
- 订单索引：支持按订单查询相关消息

---

## 🔐 安全与风控体系

### 1. 数据安全保护

#### 用户隐私保护
- **数据脱敏**：敏感信息在日志和接口中自动脱敏处理
- **访问控制**：基于角色的细粒度权限控制，最小权限原则
- **数据加密**：
  - 用户地址等敏感信息采用AES-256加密存储
  - 密码和支付PIN使用bcrypt哈希存储
  - 数据库传输使用TLS 1.3加密

#### 支付安全机制
- **HD钱包安全**：
  - 商家私钥永不触碰服务器，仅存储xpub
  - 地址生成算法采用BIP44标准，确保地址唯一性
  - 区块链交易监控采用多节点验证
- **支付风控**：
  - 异常金额检测（连续小额/整数金额）
  - 支付行为分析（频次、时间、IP等）
  - 实时欺诈检测引擎

### 2. 业务风控引擎

#### 实时风控算法
```javascript
// 用户行为风险评分模型
const riskScoringModel = {
  // 设备风险（25%权重）
  deviceRisk: {
    newDevice: 20,           // 新设备登录
    suspiciousUA: 15,        // 可疑User Agent
    proxyIP: 25,             // 代理IP访问
    locationChange: 10       // 异常地理位置
  },
  
  // 行为风险（35%权重）
  behaviorRisk: {
    rapidOrders: 30,         // 快速连续下单
    abnormalAmount: 25,      // 异常金额模式
    duplicateAddress: 20,    // 重复收货地址
    paymentPatterns: 15      // 异常支付模式
  },
  
  // 账户风险（25%权重）
  accountRisk: {
    newAccount: 20,          // 新注册账户
    lowActivity: 10,         // 活跃度低
    historicalIssues: 30,    // 历史问题记录
    verificationStatus: 15   // 验证状态
  },
  
  // 交易风险（15%权重）
  transactionRisk: {
    highValue: 25,           // 高价值交易
    timePattern: 15,         // 时间模式异常
    frequencyPattern: 20     // 频次模式异常
  }
};
```

#### 多层级风控策略
```javascript
// 风控处理策略分级
const riskHandlingStrategy = {
  level1_monitor: {         // 0-30分：正常监控
    actions: ['log_activity', 'normal_process'],
    reviewRequired: false
  },
  
  level2_caution: {         // 31-50分：谨慎处理
    actions: ['enhanced_logging', 'delayed_confirmation'],
    reviewRequired: false,
    additionalChecks: ['address_verification', 'payment_method_check']
  },
  
  level3_review: {          // 51-70分：人工审核
    actions: ['manual_review', 'transaction_hold'],
    reviewRequired: true,
    reviewTimeout: 3600,    // 1小时内必须处理
    autoActions: ['notification_to_admin']
  },
  
  level4_restrict: {        // 71-85分：限制操作
    actions: ['restrict_transactions', 'require_verification'],
    reviewRequired: true,
    restrictions: {
      maxDailyAmount: 100,  // 每日限额100 USDT
      maxTransactions: 3,   // 每日最多3笔
      requireApproval: true // 所有交易需要审批
    }
  },
  
  level5_block: {           // 86-100分：阻止操作
    actions: ['block_transactions', 'account_freeze'],
    reviewRequired: true,
    blockDuration: 86400,   // 24小时冻结
    unblockConditions: ['manual_approval', 'identity_verification']
  }
};
```

### 3. 系统监控与告警

#### 实时监控指标
```yaml
# 监控配置
monitoring:
  performance:
    api_response_time: 
      warning: 500ms
      critical: 2000ms
    database_connection:
      warning: 80%
      critical: 95%
    memory_usage:
      warning: 70%
      critical: 90%
      
  business:
    order_success_rate:
      warning: 85%
      critical: 70%
    payment_success_rate:
      warning: 90%
      critical: 80%
    user_complaint_rate:
      warning: 5%
      critical: 10%
      
  security:
    failed_login_attempts:
      threshold: 10/minute
      action: temporary_ip_block
    suspicious_transactions:
      threshold: 5/hour
      action: alert_admin
    ddos_detection:
      threshold: 1000_requests/minute
      action: rate_limit_strict
```

#### 智能告警系统
```javascript
// 告警规则引擎
const alertRules = {
  // 业务异常告警
  business_anomaly: {
    payment_failure_spike: {
      condition: 'payment_failure_rate > 20% AND time_window = 15min',
      severity: 'high',
      notifications: ['telegram', 'email', 'sms'],
      autoActions: ['investigate_payment_gateway', 'switch_backup_gateway']
    },
    
    unusual_traffic: {
      condition: 'order_volume > avg_7day * 3 AND time_window = 1hour',
      severity: 'medium',
      notifications: ['telegram', 'email'],
      autoActions: ['increase_server_capacity', 'enable_rate_limiting']
    }
  },
  
  // 安全威胁告警
  security_threat: {
    brute_force_attack: {
      condition: 'failed_logins > 100 AND source_ip = same AND time_window = 5min',
      severity: 'critical',
      notifications: ['telegram', 'email', 'sms', 'webhook'],
      autoActions: ['block_ip_immediately', 'escalate_to_security_team']
    },
    
    mass_registration: {
      condition: 'new_users > 100 AND time_window = 10min',
      severity: 'medium',
      notifications: ['telegram', 'email'],
      autoActions: ['enable_captcha', 'require_phone_verification']
    }
  },
  
  // 系统性能告警
  performance_issue: {
    database_slow_query: {
      condition: 'query_time > 5s AND frequency > 10/minute',
      severity: 'high',
      notifications: ['telegram', 'email'],
      autoActions: ['log_slow_queries', 'analyze_query_plan']
    },
    
    memory_leak: {
      condition: 'memory_usage_growth > 10%/hour AND duration > 2hour',
      severity: 'critical',
      notifications: ['telegram', 'email', 'sms'],
      autoActions: ['trigger_memory_dump', 'restart_affected_services']
    }
  }
};
```

### 4. 容灾与备份策略

#### 数据备份机制
```yaml
backup_strategy:
  database:
    full_backup:
      frequency: daily
      time: "02:00"
      retention: 30_days
      storage: ["local_disk", "cloud_storage", "remote_datacenter"]
      
    incremental_backup:
      frequency: every_4_hours
      retention: 7_days
      
    transaction_log_backup:
      frequency: every_15_minutes
      retention: 24_hours
      
  file_storage:
    images_backup:
      frequency: daily
      retention: 90_days
      sync_method: rsync
      
    logs_backup:
      frequency: daily
      retention: 365_days
      compression: gzip
      
  configuration:
    config_backup:
      frequency: before_each_deployment
      retention: permanent
      version_control: git
```

#### 灾难恢复预案
```javascript
// 灾难恢复流程
const disasterRecoveryPlan = {
  rto: 4_hours,  // 恢复时间目标：4小时
  rpo: 15_minutes, // 恢复点目标：最多丢失15分钟数据
  
  scenarios: {
    database_failure: {
      detection: 'automated_health_check',
      response_time: '< 5 minutes',
      recovery_steps: [
        'switch_to_read_replica',
        'assess_primary_damage',
        'restore_from_latest_backup',
        'replay_transaction_logs',
        'verify_data_integrity',
        'redirect_traffic_to_recovered_instance'
      ]
    },
    
    complete_datacenter_outage: {
      detection: 'multi_service_failure',
      response_time: '< 30 minutes',
      recovery_steps: [
        'activate_secondary_datacenter',
        'update_dns_records',
        'restore_latest_backup_to_secondary',
        'verify_all_services_operational',
        'communicate_with_stakeholders'
      ]
    },
    
    security_breach: {
      detection: 'security_monitoring_system',
      response_time: '< 10 minutes',
      recovery_steps: [
        'isolate_affected_systems',
        'preserve_forensic_evidence',
        'reset_all_authentication_tokens',
        'force_user_password_reset',
        'conduct_security_audit',
        'implement_additional_security_measures'
      ]
    }
  }
};
```

### 5. 合规与审计

#### 数据合规要求
```yaml
compliance_framework:
  data_protection:
    gdpr_compliance:
      data_minimization: true
      purpose_limitation: true
      storage_limitation: 
        user_data: 2_years_after_last_activity
        transaction_data: 7_years
        logs: 1_year
      right_to_erasure: implemented
      data_portability: supported
      
    local_regulations:
      user_age_verification: required
      kyc_requirements: conditional
      transaction_reporting: 
        threshold: 10000_usd
        frequency: monthly
        
  audit_trails:
    user_actions:
      login_logout: logged
      transactions: logged
      sensitive_operations: logged
      retention: 3_years
      
    admin_actions:
      all_operations: logged
      approval_workflows: tracked
      configuration_changes: versioned
      retention: 7_years
      
    system_events:
      security_events: logged
      performance_metrics: tracked
      error_conditions: logged
      retention: 1_year
```

### 6. API安全与限流

#### API访问控制
```javascript
// API安全配置
const apiSecurityConfig = {
  authentication: {
    jwt_expiry: '1_hour',
    refresh_token_expiry: '30_days',
    max_concurrent_sessions: 5,
    
    rate_limiting: {
      global: '1000_requests/minute',
      per_user: '100_requests/minute',
      per_ip: '500_requests/minute',
      
      endpoints: {
        '/api/auth/login': '5_requests/minute',
        '/api/orders/create': '10_requests/minute',
        '/api/payments/process': '3_requests/minute'
      }
    }
  },
  
  input_validation: {
    sanitization: {
      html_entities: true,
      sql_injection: true,
      xss_prevention: true
    },
    
    size_limits: {
      request_body: '1MB',
      file_upload: '10MB',
      image_upload: '5MB'
    }
  },
  
  security_headers: {
    'Content-Security-Policy': "default-src 'self'",
    'X-Frame-Options': 'DENY',
    'X-Content-Type-Options': 'nosniff',
    'Strict-Transport-Security': 'max-age=31536000',
    'X-XSS-Protection': '1; mode=block'
  }
};
```

---

## 🚀 性能优化策略

### 1. 数据库优化

#### 索引优化策略
```sql
-- 关键查询优化索引
-- 订单查询优化
CREATE INDEX idx_orders_user_status ON orders(user_id, status, created_at);
CREATE INDEX idx_orders_merchant_payment ON orders(merchant_id, payment_status, created_at);
CREATE INDEX idx_orders_delivery_region ON orders(region_id, delivery_staff_id, status);

-- 用户行为优化
CREATE INDEX idx_point_transactions_user_type ON point_transactions(user_id, type, created_at);
CREATE INDEX idx_messages_conversation ON messages(from_user_id, to_user_id, created_at);

-- 商品查询优化
CREATE INDEX idx_products_region_status ON products(region_ids, status, audit_status);
CREATE INDEX idx_products_category_member ON products(category_id, is_member_only, status);

-- 分区策略
-- 按时间分区大表
ALTER TABLE orders PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

ALTER TABLE point_transactions PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

#### 查询优化技巧
```javascript
// 复杂查询优化示例
const optimizedQueries = {
  // 用户订单统计（避免全表扫描）
  getUserOrderStats: `
    SELECT 
      u.user_id,
      u.total_orders,
      u.total_spent,
      COALESCE(recent.recent_orders, 0) as orders_30days,
      COALESCE(recent.recent_spent, 0) as spent_30days
    FROM users u
    LEFT JOIN (
      SELECT 
        user_id,
        COUNT(*) as recent_orders,
        SUM(total_amount) as recent_spent
      FROM orders 
      WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        AND status = 'completed'
      GROUP BY user_id
    ) recent ON u.user_id = recent.user_id
    WHERE u.user_id = ?
  `,
  
  // 热销商品查询（使用覆盖索引）
  getHotProducts: `
    SELECT 
      p.product_id,
      p.name,
      p.price_config,
      p.sales_count,
      p.stock
    FROM products p
    WHERE p.region_ids JSON_CONTAINS(?, CAST(? AS JSON))
      AND p.status = 'active'
      AND p.audit_status = 'approved'
      AND p.stock > 0
    ORDER BY p.sales_count DESC, p.created_at DESC
    LIMIT 20
  `,
  
  // 商家销售统计（时间范围优化）
  getMerchantSalesStats: `
    SELECT 
      DATE(created_at) as sales_date,
      COUNT(*) as order_count,
      SUM(total_amount) as total_sales,
      SUM(profit_amount) as total_profit
    FROM orders
    WHERE merchant_id = ?
      AND status = 'completed'
      AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY DATE(created_at)
    ORDER BY sales_date DESC
  `
};
```

### 2. 缓存策略

#### 多层级缓存架构
```javascript
// 缓存架构设计
const cacheStrategy = {
  // L1: 应用内存缓存 (最快，容量小)
  l1_memory: {
    type: 'LRU',
    max_size: '100MB',
    ttl: '5_minutes',
    items: [
      'user_permissions',
      'product_hot_list',
      'exchange_rates',
      'system_configs'
    ]
  },
  
  // L2: Redis缓存 (快，容量中等)
  l2_redis: {
    type: 'Redis Cluster',
    max_size: '10GB',
    ttl: '1_hour',
    items: [
      'user_profiles',
      'product_details',
      'order_status',
      'inventory_counts',
      'session_data'
    ]
  },
  
  // L3: PostgreSQL查询缓存 (较慢，容量大)
  l3_database: {
    type: 'PostgreSQL Query Cache',
    max_size: '50GB',
    ttl: '24_hours',
    items: [
      'complex_analytics',
      'historical_reports',
      'aggregated_statistics'
    ]
  }
};

// 缓存更新策略
const cacheUpdateStrategy = {
  // 写穿模式 (Write-Through)
  user_profile: {
    on_update: 'update_cache_sync',
    fallback: 'load_from_database'
  },
  
  // 写回模式 (Write-Back)
  inventory_count: {
    on_update: 'update_cache_async',
    batch_write: 'every_5_minutes'
  },
  
  // 写绕模式 (Write-Around)
  historical_data: {
    on_update: 'invalidate_cache',
    reload: 'on_next_read'
  }
};
```

#### 缓存键命名规范
```javascript
// 统一的缓存键命名规范
const cacheKeyPatterns = {
  user: 'user:{user_id}',
  user_orders: 'user:{user_id}:orders:{status?}',
  user_points: 'user:{user_id}:points',
  
  product: 'product:{product_id}',
  product_list: 'products:region:{region_id}:status:{status}',
  product_hot: 'products:hot:region:{region_id}:limit:{limit}',
  
  order: 'order:{order_id}',
  order_payment: 'order:{order_id}:payment',
  
  merchant: 'merchant:{merchant_id}',
  merchant_sales: 'merchant:{merchant_id}:sales:{date_range}',
  
  system: 'system:config:{key}',
  system_stats: 'system:stats:{metric}:{period}'
};

// 缓存过期策略
const cacheExpirationPolicy = {
  immediate: 0,           // 立即过期
  short: 300,            // 5分钟
  medium: 1800,          // 30分钟  
  long: 3600,            // 1小时
  daily: 86400,          // 24小时
  weekly: 604800,        // 7天
  permanent: -1          // 永不过期
};
```

### 3. 异步处理优化

#### 消息队列架构
```javascript
// 消息队列配置
const messageQueueConfig = {
  // 高优先级队列（订单、支付）
  high_priority: {
    queue_name: 'vape_bot_high',
    max_workers: 10,
    retry_attempts: 3,
    retry_delay: '1s,5s,30s',
    timeout: 30000,
    
    tasks: [
      'process_payment',
      'create_order',
      'update_order_status',
      'send_urgent_notification'
    ]
  },
  
  // 中优先级队列（通知、更新）
  medium_priority: {
    queue_name: 'vape_bot_medium',
    max_workers: 5,
    retry_attempts: 2,
    retry_delay: '5s,30s',
    timeout: 60000,
    
    tasks: [
      'send_notification',
      'update_user_stats',
      'process_points',
      'generate_reports'
    ]
  },
  
  // 低优先级队列（分析、清理）
  low_priority: {
    queue_name: 'vape_bot_low',
    max_workers: 2,
    retry_attempts: 1,
    retry_delay: '60s',
    timeout: 300000,
    
    tasks: [
      'cleanup_expired_data',
      'generate_analytics',
      'backup_database',
      'send_marketing_messages'
    ]
  }
};

// 任务处理示例
const taskHandlers = {
  async process_payment(payload) {
    const { order_id, payment_hash, amount } = payload;
    
    try {
      // 验证支付
      const verified = await verifyBlockchainTransaction(payment_hash, amount);
      
      if (verified) {
        // 更新订单状态
        await updateOrderPaymentStatus(order_id, 'paid');
        
        // 发送确认通知
        await sendPaymentConfirmation(order_id);
        
        // 更新商家销售统计
        await updateMerchantStats(order_id);
        
        // 处理推广返利
        await processReferralBonus(order_id);
        
        return { success: true };
      } else {
        throw new Error('Payment verification failed');
      }
    } catch (error) {
      // 记录错误并重试
      await logPaymentError(order_id, error);
      throw error;
    }
  },
  
  async send_notification(payload) {
    const { user_id, message, priority } = payload;
    
    try {
      // 检查用户通知偏好
      const preferences = await getUserNotificationPreferences(user_id);
      
      if (preferences.enabled) {
        // 发送Telegram消息
        await sendTelegramMessage(user_id, message);
        
        // 记录发送日志
        await logNotificationSent(user_id, message);
        
        return { success: true };
      } else {
        return { success: true, skipped: 'user_disabled_notifications' };
      }
    } catch (error) {
      await logNotificationError(user_id, error);
      throw error;
    }
  }
};
```

### 4. 前端性能优化

#### Bot响应优化
```javascript
// Telegram Bot性能优化
const botOptimization = {
  // 响应时间优化
  response_optimization: {
    // 预加载常用数据
    preload_data: [
      'user_profile',
      'region_list',
      'hot_products',
      'user_orders_summary'
    ],
    
    // 分页加载
    pagination: {
      products_per_page: 10,
      orders_per_page: 5,
      messages_per_page: 20
    },
    
    // 懒加载策略
    lazy_loading: {
      product_images: true,
      order_details: true,
      user_history: true
    }
  },
  
  // 消息发送优化
  message_optimization: {
    // 批量发送
    batch_sending: {
      max_batch_size: 30,
      batch_interval: 1000 // 1秒
    },
    
    // 消息压缩
    message_compression: {
      long_text: true,
      repeated_content: true,
      template_reuse: true
    },
    
    // 媒体优化
    media_optimization: {
      image_compression: 80,
      max_image_size: '2MB',
      supported_formats: ['jpg', 'png', 'webp']
    }
  }
};

// 用户交互优化
const userInteractionOptimization = {
  // 智能预测
  predictive_loading: {
    // 预测用户下一步操作
    next_action_prediction: {
      browse_products: 'preload_product_list',
      view_orders: 'preload_recent_orders',
      check_points: 'preload_point_history'
    }
  },
  
  // 个性化界面
  personalized_interface: {
    // 根据使用习惯调整菜单
    adaptive_menu: {
      frequent_functions: 'move_to_top',
      unused_functions: 'move_to_bottom',
      recent_regions: 'quick_access'
    },
    
    // 智能推荐
    smart_recommendations: {
      products: 'based_on_purchase_history',
      regions: 'based_on_location',
      payment_methods: 'based_on_preference'
    }
  }
};
```

---

## 📊 监控与分析系统

### 1. 业务指标监控

#### 核心KPI仪表板
```javascript
// 实时业务监控指标
const businessMetrics = {
  // 交易相关指标
  transaction_metrics: {
    // 实时交易量
    real_time_gmv: {
      current_hour: 'sum(orders.total_amount) WHERE created_at >= current_hour',
      today: 'sum(orders.total_amount) WHERE DATE(created_at) = CURDATE()',
      target_achievement: 'current / target * 100'
    },
    
    // 订单转化率
    conversion_rate: {
      browse_to_cart: 'users_add_cart / users_browse_products * 100',
      cart_to_order: 'orders_created / carts_created * 100',
      order_to_payment: 'orders_paid / orders_created * 100',
      overall_conversion: 'orders_paid / unique_visitors * 100'
    },
    
    // 支付成功率
    payment_success_rate: {
      by_method: {
        huiwang: 'huiwang_success / huiwang_attempts * 100',
        usdt: 'usdt_success / usdt_attempts * 100',
        eth: 'eth_success / eth_attempts * 100'
      },
      overall: 'total_success / total_attempts * 100',
      trend: '7_day_moving_average'
    }
  },
  
  // 用户行为指标
  user_behavior_metrics: {
    // 用户活跃度
    user_activity: {
      dau: 'count(distinct user_id) WHERE last_active >= today',
      mau: 'count(distinct user_id) WHERE last_active >= 30_days_ago',
      session_duration: 'avg(session_end - session_start)',
      bounce_rate: 'single_action_sessions / total_sessions * 100'
    },
    
    // 用户留存
    user_retention: {
      day_1: 'users_active_day1 / new_users_yesterday * 100',
      day_7: 'users_active_day7 / new_users_7days_ago * 100',
      day_30: 'users_active_day30 / new_users_30days_ago * 100',
      cohort_analysis: 'weekly_cohort_retention_matrix'
    },
    
    // 用户价值
    user_value: {
      ltv: 'total_revenue / unique_customers',
      arpu: 'total_revenue / active_users',
      repeat_purchase_rate: 'repeat_customers / total_customers * 100',
      avg_order_value: 'total_revenue / total_orders'
    }
  },
  
  // 运营效率指标
  operational_metrics: {
    // 订单处理效率
    order_processing: {
      avg_processing_time: 'avg(paid_at - created_at)',
      delivery_success_rate: 'delivered_orders / total_orders * 100',
      avg_delivery_time: 'avg(completed_at - paid_at)',
      customer_satisfaction: 'positive_reviews / total_reviews * 100'
    },
    
    // 客服效率
    customer_service: {
      avg_response_time: 'avg(first_response_at - request_at)',
      resolution_rate: 'resolved_tickets / total_tickets * 100',
      customer_satisfaction: 'satisfied_customers / surveyed_customers * 100',
      ticket_volume: 'count(tickets) GROUP BY hour'
    }
  }
};
```

#### 预警规则配置
```javascript
// 业务预警规则
const businessAlerts = {
  // 交易异常预警
  transaction_alerts: {
    payment_failure_spike: {
      condition: 'payment_failure_rate > 15% IN last_15_minutes',
      severity: 'high',
      actions: ['alert_finance_team', 'check_payment_gateway'],
      notification_channels: ['telegram', 'email', 'sms']
    },
    
    order_volume_drop: {
      condition: 'current_hour_orders < avg_same_hour_last_7days * 0.5',
      severity: 'medium',
      actions: ['alert_operations_team', 'check_system_status'],
      notification_channels: ['telegram', 'email']
    },
    
    unusual_refund_rate: {
      condition: 'daily_refund_rate > 10%',
      severity: 'medium',
      actions: ['alert_customer_service', 'review_recent_orders'],
      notification_channels: ['telegram', 'email']
    }
  },
  
  // 用户行为异常
  user_behavior_alerts: {
    dau_significant_drop: {
      condition: 'today_dau < yesterday_dau * 0.7',
      severity: 'high',
      actions: ['alert_product_team', 'check_app_issues'],
      notification_channels: ['telegram', 'email', 'slack']
    },
    
    conversion_rate_drop: {
      condition: 'hourly_conversion_rate < avg_same_hour_last_7days * 0.8',
      severity: 'medium',
      actions: ['alert_marketing_team', 'review_user_journey'],
      notification_channels: ['telegram', 'email']
    }
  },
  
  // 库存预警
  inventory_alerts: {
    low_stock: {
      condition: 'product_stock <= stock_warning_threshold',
      severity: 'medium',
      actions: ['alert_merchant', 'send_restock_reminder'],
      notification_channels: ['telegram', 'email']
    },
    
    out_of_stock: {
      condition: 'product_stock = 0 AND status = active',
      severity: 'high',
      actions: ['auto_disable_product', 'alert_merchant'],
      notification_channels: ['telegram', 'email', 'sms']
    }
  }
};
```

### 2. 用户行为分析

#### 用户旅程分析
```javascript
// 用户行为分析模型
const userAnalytics = {
  // 用户旅程映射
  user_journey_mapping: {
    // 新用户激活流程
    new_user_activation: {
      steps: [
        'bot_start',
        'welcome_message_shown',
        'first_product_browse',
        'first_cart_add',
        'first_order_create',
        'first_payment_complete'
      ],
      conversion_tracking: {
        step_by_step_rate: true,
        drop_off_analysis: true,
        time_between_steps: true
      }
    },
    
    // 购买决策流程
    purchase_decision: {
      steps: [
        'product_list_view',
        'product_detail_view',
        'specification_selection',
        'add_to_cart',
        'checkout_initiate',
        'payment_method_select',
        'payment_complete'
      ],
      influencing_factors: [
        'product_price',
        'product_reviews',
        'shipping_cost',
        'payment_convenience'
      ]
    }
  },
  
  // 用户细分模型
  user_segmentation: {
    // 基于价值的细分
    value_based: {
      high_value: 'ltv > 1000 AND orders > 20',
      medium_value: 'ltv BETWEEN 200 AND 1000',
      low_value: 'ltv < 200',
      
      characteristics: {
        high_value: ['frequent_purchaser', 'high_aov', 'loyal'],
        medium_value: ['occasional_purchaser', 'medium_aov', 'price_sensitive'],
        low_value: ['rare_purchaser', 'low_aov', 'deal_seeker']
      }
    },
    
    // 基于行为的细分
    behavior_based: {
      power_users: 'daily_active AND high_engagement',
      casual_users: 'weekly_active AND medium_engagement',
      inactive_users: 'no_activity_30days',
      
      engagement_metrics: [
        'session_frequency',
        'session_duration',
        'feature_usage_depth',
        'content_interaction_rate'
      ]
    }
  },
  
  // 个性化推荐引擎
  recommendation_engine: {
    // 协同过滤
    collaborative_filtering: {
      user_based: 'recommend_based_on_similar_users',
      item_based: 'recommend_based_on_similar_products',
      matrix_factorization: 'advanced_ml_recommendations'
    },
    
    // 内容过滤
    content_filtering: {
      product_attributes: ['category', 'price_range', 'brand'],
      user_preferences: ['past_purchases', 'browsing_history', 'ratings'],
      contextual_factors: ['time_of_day', 'location', 'device']
    }
  }
};
```

### 3. 财务分析报表

#### 收入分析模型
```javascript
// 财务分析配置
const financialAnalytics = {
  // 收入分析
  revenue_analysis: {
    // 多维度收入统计
    multi_dimensional_revenue: {
      by_time: {
        hourly: 'SUM(total_amount) GROUP BY HOUR(created_at)',
        daily: 'SUM(total_amount) GROUP BY DATE(created_at)',
        weekly: 'SUM(total_amount) GROUP BY WEEK(created_at)',
        monthly: 'SUM(total_amount) GROUP BY MONTH(created_at)'
      },
      
      by_geography: {
        country: 'SUM(total_amount) GROUP BY country_id',
        region: 'SUM(total_amount) GROUP BY region_id',
        city: 'SUM(total_amount) GROUP BY delivery_city'
      },
      
      by_product: {
        category: 'SUM(total_amount) GROUP BY product_category',
        individual: 'SUM(total_amount) GROUP BY product_id',
        merchant: 'SUM(total_amount) GROUP BY merchant_id'
      },
      
      by_customer: {
        segment: 'SUM(total_amount) GROUP BY customer_segment',
        membership: 'SUM(total_amount) GROUP BY member_type',
        acquisition_channel: 'SUM(total_amount) GROUP BY referrer_source'
      }
    },
    
    // 利润分析
    profit_analysis: {
      gross_profit: {
        calculation: 'revenue - cost_of_goods_sold',
        margin: 'gross_profit / revenue * 100',
        by_product: 'GROUP BY product_id',
        by_merchant: 'GROUP BY merchant_id'
      },
      
      operating_profit: {
        calculation: 'gross_profit - operating_expenses',
        operating_expenses: [
          'platform_maintenance',
          'customer_service',
          'marketing_costs',
          'payment_processing_fees'
        ]
      },
      
      contribution_margin: {
        by_user: '(revenue - variable_costs) / user',
        by_product: '(revenue - variable_costs) / product',
        by_region: '(revenue - variable_costs) / region'
      }
    }
  },
  
  // 成本分析
  cost_analysis: {
    // 运营成本分解
    operational_costs: {
      technology: {
        server_costs: 'monthly_server_fees',
        software_licenses: 'third_party_services',
        development: 'developer_salaries + contractor_fees'
      },
      
      human_resources: {
        customer_service: 'cs_team_salaries',
        operations: 'ops_team_salaries',
        management: 'management_salaries'
      },
      
      marketing: {
        user_acquisition: 'ad_spend + referral_bonuses',
        retention: 'loyalty_program_costs',
        promotion: 'discount_costs + coupon_redemptions'
      }
    },
    
    // 可变成本
    variable_costs: {
      payment_processing: 'transaction_fees',
      delivery: 'delivery_costs',
      customer_support: 'support_costs_per_order',
      referral_bonuses: 'referral_payouts'
    }
  },
  
  // 财务预测
  financial_forecasting: {
    // 收入预测模型
    revenue_forecasting: {
      time_series: 'arima_model_based_on_historical_data',
      regression: 'multiple_regression_with_external_factors',
      machine_learning: 'lstm_neural_network_prediction'
    },
    
    // 现金流预测
    cash_flow_forecasting: {
      operating_cash_flow: 'predicted_revenue - predicted_expenses',
      investment_cash_flow: 'planned_capex + planned_investments',
      financing_cash_flow: 'planned_funding - debt_payments'
    }
  }
};
```

---

## 🔐 安全与风控体系

- Webhook + HTTPS：所有回调使用 HTTPS Webhook，证书自动更新，确保消息实时可靠。
- 幂等处理：对支付、消息、授权等关键回调进行幂等判断，避免重复处理。
- 监控告警：Webhook 失败、支付延迟、系统异常日志超过阈值时触发多渠道报警。
- 日志审计：请求链路采用`trace_id`串联，支持全链路追踪和审计。
- 访问控制：后台操作敏感接口使用多因素认证。

---

## 🔧 技术选型说明

### 核心技术栈架构
本项目采用 **aiogram 3.20.0 + PostgreSQL 16+ + SQLModel 0.0.24 + Redis 6.2.0** 的现代化技术架构，确保高性能、高可靠性和良好的开发体验。

### 框架选择理由

#### **aiogram 3.20.0** - Telegram Bot开发框架
**选择原因**：
- **异步支持**：基于asyncio，支持高并发处理，适合处理大量用户同时下单的场景
- **完善的FSM状态管理**：内置状态机支持，完美处理多步骤购买流程（选择商品→配送信息→支付确认）
- **双模式支持**：同时支持Webhook和Long Polling，确保部署灵活性
- **丰富的中间件生态**：支持自定义中间件，便于实现权限控制、日志记录、错误处理
- **类型安全**：完整的类型注解支持，提高代码质量和开发效率
- **官方维护**：活跃的社区支持，及时跟进Telegram Bot API更新

**核心优势**：
**状态机设计**：支持多步骤购买流程状态管理
- 商品选择状态
- 数量输入状态  
- 配送方式选择状态
- 支付确认状态

#### **PostgreSQL 16+** - 主数据库
**选择原因**：
- **JSONB原生支持**：完美存储商品规格、用户偏好等半结构化数据，查询性能优异
- **事务ACID特性**：严格保证订单、支付、库存的数据一致性，防止超卖和重复扣款
- **丰富索引类型**：GIN/GiST索引支持全文搜索、地理位置查询等复杂业务场景
- **分区表支持**：大订单表可按时间分区，提升查询性能
- **成熟高可用方案**：支持主从复制、流复制、逻辑复制等多种高可用架构
- **强大扩展能力**：丰富的扩展插件支持时序数据、向量搜索等高级功能

**核心优势**：
**数据结构设计**：
- 产品表：支持JSONB存储灵活商品规格（口味等）
- 定价表：支持JSONB存储阶梯价格（不同数量对应不同价格）
- 搜索优化：支持GIN索引的中文全文搜索功能

#### **SQLModel 0.0.24** - ORM框架
**选择原因**：
- **Pydantic集成**：自动数据验证和序列化，减少手动类型检查代码
- **异步ORM支持**：与aiogram异步架构完美配合，避免阻塞操作
- **类型安全**：编译时类型检查，减少运行时错误
- **FastAPI生态兼容**：未来如需API扩展，可无缝集成FastAPI
- **简洁语法**：相比传统ORM，代码更简洁易维护

**核心优势**：
```python
# 类型安全的数据模型
class Order(SQLModel, table=True):
    id: Optional[int] = Field(primary_key=True)
    user_id: int = Field(foreign_key="users.id")
    total_amount: Decimal = Field(decimal_places=2)
    status: OrderStatus
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

#### **Redis 6.2.0** - 缓存和会话存储
**选择原因**：
**数据模型设计**：
- 支持Pydantic自动数据验证和序列化
- 异步ORM与数据库操作，避免阻塞
- 类型安全的编译时检查
- 简洁的模型定义语法

**核心特性**：
- 订单模型：包含用户、商品、支付、配送等完整信息
- 商品模型：支持灵活的规格和定价结构
- 用户模型：多级权限和身份管理
- 事务模型：支付、库存、订单状态一致性

#### **Redis 7+** - 缓存与会话存储
**选择原因**：
- **高性能缓存**：毫秒级响应，缓存热点商品数据，减少数据库压力
- **FSM状态存储**：完美支持aiogram状态机，存储用户购买流程状态
- **分布式锁支持**：防止库存超卖等并发问题
- **消息队列功能**：支持异步任务处理，如订单通知、库存更新
- **数据持久化**：支持RDB和AOF，保证重要缓存数据不丢失
- **集群支持**：Redis Cluster模式支持水平扩展

**核心优势**：
**多层级缓存架构设计**：
- L1缓存：Redis毫秒级响应，缓存热点商品
- L2缓存：数据库查询备份机制
- 缓存策略：30分钟缓存时间，自动更新机制
- 缓存预热：系统启动时预加载热门商品

### 技术架构优势总结

1. **高性能**：异步架构 + Redis缓存 + PostgreSQL优化查询
2. **高可靠**：数据库事务 + 消息幂等 + 异常处理
3. **高扩展**：分布式架构 + 微服务友好 + 水平扩展支持
4. **开发友好**：类型安全 + 现代语法 + 丰富生态
5. **运维友好**：完善监控 + 日志审计 + 自动化部署

---

## 🏗️ 技术实现架构

### 1. aiogram 3.20.0 框架实现（增强版）

#### 核心中间件系统设计
**中间件功能需求**：
- 错误处理中间件：统一异常处理和用户提示
- 权限控制中间件：用户身份验证和功能访问控制
- 访问限制中间件：防止恶意刷屏和API滥用
- 日志记录中间件：完整的操作审计和监控
- 文件处理中间件：图片上传和文件管理
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery
from aiogram.exceptions import TelegramAPIError, TelegramBadRequest, TelegramRetryAfter
from PIL import Image
import io

logger = structlog.get_logger()

class ErrorHandlingMiddleware(BaseMiddleware):
    """完善的异常处理中间件"""
    
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        try:
            return await handler(event, data)
        except TelegramRetryAfter as e:
            logger.warning("Rate limit hit", retry_after=e.retry_after)
**错误处理中间件设计**：
- 统一捕获和处理所有异常
- 区分不同类型错误并给出相应提示
- 支持重试机制处理临时性错误
- 记录详细错误日志用于故障排查

**错误处理策略**：
- 速率限制错误：自动等待后重试
- 请求格式错误：提示用户检查输入
- API错误：根据错误码提供具体说明
- 意外错误：记录完整异常信息并通用提示

**用户友好的错误提示**：
- Bad Request (400)：请求参数错误
- Unauthorized (401)：Bot令牌无效  
- Forbidden (403)：权限不足或被屏蔽
- Not Found (404)：资源不存在
- Too Many Requests (429)：请求频繁，稍后重试
- Internal Server Error (500)：Telegram服务器错误

#### 访问限制中间件设计
**频率限制策略**：
- 默认限制：每分钟25条消息（留5条缓冲）
- 时间窗口：60秒滑动窗口
- 用户级别限制：防止单用户刷屏
- 全局流量控制：保护系统整体性能

**限制检查机制**：
- 实时记录用户请求时间戳
- 自动清理过期的请求记录
- 超过限制时友好提示用户
- 支持不同用户等级的差异化限制
    
    def _cleanup_expired_requests(self, now: float):
        """清理过期的请求记录"""
        cutoff = now - self.window
        
        # 清理用户请求记录
        for user_id in list(self.user_requests.keys()):
            self.user_requests[user_id] = [
                req_time for req_time in self.user_requests[user_id] 
                if req_time > cutoff
            ]
            if not self.user_requests[user_id]:
                del self.user_requests[user_id]
        
        # 清理全局请求记录
        self.global_requests[:] = [
            req_time for req_time in self.global_requests 
            if req_time > cutoff
        ]
    
    async def _check_user_rate_limit(self, user_id: int, now: float) -> bool:
        """检查用户请求频率"""
        user_reqs = self.user_requests[user_id]
        
        if len(user_reqs) >= self.default_limit:
            return False
        
        # 记录当前请求
        user_reqs.append(now)
        self.global_requests.append(now)
        return True

class FileUploadMiddleware(BaseMiddleware):
    """文件上传处理中间件"""
    
    MAX_FILE_SIZE = 20 * 1024 * 1024  # 20MB (Telegram下载限制)
    MAX_IMAGE_SIZE = (1920, 1920)     # 最大图片尺寸
    SUPPORTED_FORMATS = {'JPEG', 'PNG', 'WEBP'}
    
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        if isinstance(event, Message) and event.photo:
            # 处理图片上传
            photo = event.photo[-1]  # 获取最大尺寸的图片
            
            if photo.file_size and photo.file_size > self.MAX_FILE_SIZE:
                await event.reply("❌ 图片文件过大，请选择小于20MB的图片")
                return
            
            try:
                # 获取文件信息并下载
                bot = data['bot']
                file_info = await bot.get_file(photo.file_id)
                image_data = await bot.download_file(file_info.file_path)
                
                # 压缩处理
                compressed_data = await self._compress_image(image_data)
                
                # 将处理后的图片数据添加到上下文
                data['processed_image'] = compressed_data
                
            except Exception as e:
                logger.error("Image processing failed", error=str(e))
                await event.reply("❌ 图片处理失败，请重试")
                return
        
        return await handler(event, data)
    
    async def _compress_image(self, image_data: bytes) -> bytes:
        """压缩图片"""
        try:
            # 打开图片
            image = Image.open(io.BytesIO(image_data))
            
            # 转换为RGB（如果是RGBA）
            if image.mode in ('RGBA', 'LA'):
                background = Image.new('RGB', image.size, (255, 255, 255))
                if image.mode == 'RGBA':
                    background.paste(image, mask=image.split()[-1])
                else:
                    background.paste(image, mask=image.split()[-1])
                image = background
            elif image.mode != 'RGB':
                image = image.convert('RGB')
            
            # 调整尺寸
            image.thumbnail(self.MAX_IMAGE_SIZE, Image.Resampling.LANCZOS)
            
            # 压缩并保存
            output = io.BytesIO()
            image.save(output, format='JPEG', quality=85, optimize=True)
            return output.getvalue()
            
        except Exception as e:
            logger.error("Image compression failed", error=str(e))
            raise

class SecurityMiddleware(BaseMiddleware):
    """安全中间件"""
    
    def __init__(self, webhook_secret: str = None):
        self.webhook_secret = webhook_secret
        self.suspicious_activities = defaultdict(list)
        
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        user_id = getattr(event, 'from_user', {}).get('id')
        
        if user_id:
            # 检查可疑活动
            if await self._check_suspicious_activity(user_id, event):
                logger.warning("Suspicious activity detected", user_id=user_id)
                return
        
        return await handler(event, data)
    
    async def _check_suspicious_activity(self, user_id: int, event) -> bool:
        """检查可疑活动"""
        now = datetime.now()
        user_activities = self.suspicious_activities[user_id]
        
        # 清理1小时前的记录
        cutoff = now - timedelta(hours=1)
        user_activities[:] = [
            activity for activity in user_activities 
            if activity['time'] > cutoff
        ]
        
        # 检查频率
        if len(user_activities) > 100:  # 1小时内超过100次操作
            return True
        
        # 记录当前活动
        user_activities.append({
            'time': now,
            'type': type(event).__name__,
            'text': getattr(event, 'text', '')[:50]  # 只记录前50个字符
        })
        
        return False

def setup_middlewares(dp: Dispatcher):
    """设置所有中间件"""
    dp.middleware.setup(ErrorHandlingMiddleware())
    dp.middleware.setup(RateLimitMiddleware())
    dp.middleware.setup(FileUploadMiddleware())
    dp.middleware.setup(SecurityMiddleware())
```

#### Bot应用结构（增强版）
```python
# main.py - 主应用入口
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.redis import RedisStorage
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
import redis.asyncio as redis
import structlog

from config import BOT_TOKEN, REDIS_URL, WEBHOOK_URL, WEBHOOK_SECRET
from handlers import register_all_handlers
from middlewares.core import setup_middlewares
from database import init_db
from utils.cache import CacheManager
from utils.monitoring import setup_monitoring

# 配置结构化日志
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

async def main():
    """主应用启动函数"""
    try:
        # 初始化Redis存储
        redis_client = redis.from_url(REDIS_URL)
        storage = RedisStorage(redis_client)
        
        # 初始化Bot和Dispatcher
        bot = Bot(token=BOT_TOKEN)
        dp = Dispatcher(storage=storage)
        
        # 初始化数据库
        await init_db()
        
        # 初始化缓存管理器
        cache_manager = CacheManager(redis_client)
        
        # 将依赖注入到上下文
        dp['cache'] = cache_manager
        dp['redis'] = redis_client
        
        # 注册处理器和中间件
        register_all_handlers(dp)
        setup_middlewares(dp)
        
        # 设置监控
        setup_monitoring(dp)
        
        # 设置Webhook
        await bot.set_webhook(
            url=WEBHOOK_URL,
            secret_token=WEBHOOK_SECRET,
            drop_pending_updates=True
        )
        
        logger.info("Bot webhook set successfully", webhook_url=WEBHOOK_URL)
        
        # 启动Web服务器
        app = web.Application()
        webhook_handler = SimpleRequestHandler(
            dispatcher=dp, 
            bot=bot,
            secret_token=WEBHOOK_SECRET
        )
        webhook_handler.register(app, path="/webhook")
        setup_application(app, dp, bot=bot)
        
        # 健康检查端点
        async def health_check(request):
            return web.json_response({"status": "healthy", "timestamp": time.time()})
        
        app.router.add_get("/health", health_check)
        
        logger.info("Starting bot server", host="0.0.0.0", port=8000)
        return app
        
    except Exception as e:
        logger.exception("Failed to start bot", error=str(e))
        raise

if __name__ == "__main__":
    app = main()
    web.run_app(app, host="0.0.0.0", port=8000)
```

#### 高级缓存管理
```python
# utils/cache.py - 高级缓存管理器
import json
import pickle
import hashlib
from typing import Optional, Callable, Any
import redis.asyncio as redis
import structlog

logger = structlog.get_logger()

class CacheManager:
    """高级缓存管理器 - 支持缓存穿透保护和分布式锁"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.null_cache_ttl = 300  # 空值缓存5分钟
        
    async def get_or_set(self, 
                        key: str, 
                        fetch_func: Callable, 
                        ttl: int = 3600,
                        use_pickle: bool = False) -> Optional[Any]:
        """缓存穿透保护的获取或设置"""
        try:
            # 尝试从缓存获取
            cached = await self.redis.get(key)
            if cached is not None:
                if cached == b"__NULL__":  # 空值标记
                    return None
                
                if use_pickle:
                    return pickle.loads(cached)
                else:
                    return json.loads(cached.decode())
            
            # 分布式锁防止缓存击穿
            lock_key = f"lock:{key}"
            async with self.redis.lock(lock_key, timeout=10, blocking_timeout=5):
                # 双重检查
                cached = await self.redis.get(key)
                if cached is not None:
                    if cached == b"__NULL__":
                        return None
                    
                    if use_pickle:
                        return pickle.loads(cached)
                    else:
                        return json.loads(cached.decode())
                
                # 获取数据
                data = await fetch_func()
                
                # 设置缓存（包括空值缓存）
                if data is None:
                    await self.redis.setex(key, self.null_cache_ttl, b"__NULL__")
                else:
                    if use_pickle:
                        cache_data = pickle.dumps(data)
                    else:
                        cache_data = json.dumps(data, default=str).encode()
                    
                    await self.redis.setex(key, ttl, cache_data)
                
                return data
                
        except Exception as e:
            logger.error("Cache operation failed", key=key, error=str(e))
            # 缓存失败时直接调用获取函数
            return await fetch_func()
    
    async def invalidate_pattern(self, pattern: str) -> int:
        """删除匹配模式的所有缓存"""
        try:
            keys = await self.redis.keys(pattern)
            if keys:
                return await self.redis.delete(*keys)
            return 0
        except Exception as e:
            logger.error("Cache invalidation failed", pattern=pattern, error=str(e))
            return 0
    
    async def get_user_session(self, user_id: int) -> Optional[dict]:
        """获取用户会话"""
        return await self.get_or_set(
            f"session:user:{user_id}",
            lambda: None,  # 空获取函数，仅用于获取
            ttl=86400
        )
    
    async def set_user_session(self, user_id: int, session_data: dict) -> bool:
        """设置用户会话"""
        try:
            return await self.redis.setex(
                f"session:user:{user_id}", 
                86400, 
                json.dumps(session_data)
            )
        except Exception as e:
            logger.error("Failed to set user session", user_id=user_id, error=str(e))
            return False
    
    async def rate_limit_check(self, user_id: int, action: str, 
                              limit: int = 10, window: int = 60) -> bool:
        """频率限制检查"""
        try:
            key = f"rate_limit:{user_id}:{action}"
            current = await self.redis.incr(key)
            if current == 1:
                await self.redis.expire(key, window)
            return current <= limit
        except Exception as e:
            logger.error("Rate limit check failed", 
                        user_id=user_id, action=action, error=str(e))
            return True  # 出错时允许通过
```

#### Telegram Business Account 集成
```python
# business/account_manager.py - Business Account功能集成
from aiogram import types
from aiogram.types import BusinessConnection, BusinessMessagesDeleted
import structlog

logger = structlog.get_logger()

class BusinessAccountManager:
    """Telegram Business Account功能管理器"""
    
    def __init__(self, bot, db_session):
        self.bot = bot
        self.db = db_session
    
    async def handle_business_connection(self, business_connection: BusinessConnection):
        """处理商家Business Account连接"""
        try:
            logger.info("Business connection event", 
                       connection_id=business_connection.id,
                       user_id=business_connection.user.id,
                       is_enabled=business_connection.is_enabled)
            
            if business_connection.is_enabled:
                # 启用商家Business Bot功能
                await self._enable_merchant_business_features(business_connection)
            else:
                # 禁用Business功能
                await self._disable_merchant_business_features(business_connection)
                
        except Exception as e:
            logger.error("Failed to handle business connection", 
                        connection_id=business_connection.id, error=str(e))
    
    async def _enable_merchant_business_features(self, connection: BusinessConnection):
        """为商家启用Business功能"""
        # 检查用户是否是已认证商家
        merchant = await self._get_merchant_by_user_id(connection.user.id)
        if not merchant:
            # 发送商家入驻邀请
            await self.bot.send_message(
                chat_id=connection.user_chat_id,
                text="🏪 检测到您连接了Business Account！\n\n"
                     "您可以申请成为我们平台的商家，享受以下特权：\n"
                     "• 📱 直接通过Business Account管理商品\n"
                     "• 💰 自动收款和订单管理\n"
                     "• 📊 实时销售数据分析\n"
                     "• 🎯 精准地区用户推送\n\n"
                     "点击下方按钮开始申请商家入驻：",
                reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                    [types.InlineKeyboardButton(
                        text="🚀 申请商家入驻", 
                        callback_data="apply_merchant"
                    )]
                ])
            )
            return
        
        # 为已有商家启用Business功能
        await self._setup_merchant_business_bot(merchant, connection)
    
    async def _setup_merchant_business_bot(self, merchant, connection: BusinessConnection):
        """设置商家Business Bot功能"""
        try:
            # 更新商家Business连接信息
            await self.db.execute(
                "UPDATE merchants SET business_connection_id = :conn_id, "
                "business_user_chat_id = :chat_id WHERE merchant_id = :merchant_id",
                {
                    "conn_id": connection.id,
                    "chat_id": connection.user_chat_id,
                    "merchant_id": merchant.merchant_id
                }
            )
            await self.db.commit()
            
            # 发送设置成功通知
            welcome_message = (
                "🎉 Business Account功能已激活！\n\n"
                "现在您可以享受以下增强功能：\n"
                "• ⚡ 客户消息自动转发到您的商务聊天\n"
                "• 📋 一键回复常见问题\n"
                "• 🔔 重要订单实时通知\n"
                "• 📊 销售数据推送\n\n"
                "开始使用Business功能："
            )
            
            await self.bot.send_message(
                chat_id=connection.user_chat_id,
                text=welcome_message,
                reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                    [
                        types.InlineKeyboardButton(
                            text="📱 设置自动回复", 
                            callback_data=f"setup_auto_reply:{merchant.merchant_id}"
                        ),
                        types.InlineKeyboardButton(
                            text="🔔 通知设置", 
                            callback_data=f"setup_notifications:{merchant.merchant_id}"
                        )
                    ],
                    [
                        types.InlineKeyboardButton(
                            text="📊 Business面板", 
                            callback_data=f"business_dashboard:{merchant.merchant_id}"
                        )
                    ]
                ])
            )
            
        except Exception as e:
            logger.error("Failed to setup merchant business bot", 
                        merchant_id=merchant.merchant_id, error=str(e))
    
    async def handle_business_message(self, message: types.Message, business_connection_id: str):
        """处理Business Account消息"""
        try:
            # 获取关联的商家信息
            merchant = await self._get_merchant_by_business_connection(business_connection_id)
            if not merchant:
                return
            
            # 检查是否是客户咨询商品
            if await self._is_product_inquiry(message):
                await self._handle_product_inquiry(message, merchant, business_connection_id)
            else:
                # 转发到商家管理员或客服
                await self._forward_to_support(message, merchant, business_connection_id)
                
        except Exception as e:
            logger.error("Failed to handle business message", 
                        business_connection_id=business_connection_id, error=str(e))
    
    async def _is_product_inquiry(self, message: types.Message) -> bool:
        """判断是否是商品咨询"""
        if not message.text:
            return False
        
        # 商品咨询关键词
        inquiry_keywords = [
            "价格", "多少钱", "库存", "有货", "购买", "下单",
            "口味", "规格", "包装", "配送", "送货"
        ]
        
        text_lower = message.text.lower()
        return any(keyword in text_lower for keyword in inquiry_keywords)
    
    async def _handle_product_inquiry(self, message: types.Message, merchant, business_connection_id: str):
        """处理商品咨询"""
        # 生成智能回复
        auto_reply = await self._generate_auto_reply(message, merchant)
        
        if auto_reply:
            await self.bot.send_message(
                business_connection_id=business_connection_id,
                chat_id=message.chat.id,
                text=auto_reply,
                reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                    [
                        types.InlineKeyboardButton(
                            text="🛒 查看商品", 
                            callback_data=f"view_products:{merchant.region_id}"
                        ),
                        types.InlineKeyboardButton(
                            text="💬 联系客服", 
                            callback_data=f"contact_support:{merchant.merchant_id}"
                        )
                    ]
                ])
            )
    
    async def _generate_auto_reply(self, message: types.Message, merchant) -> str:
        """生成智能自动回复"""
        # 获取商家热门商品
        popular_products = await self._get_popular_products(merchant.merchant_id)
        
        if "价格" in message.text or "多少钱" in message.text:
            return (
                f"💰 {merchant.merchant_name} 商品价格说明\n\n"
                f"我们提供多种规格和价位的电子烟产品：\n"
                f"• 入门款：88-158元\n"
                f"• 进阶款：188-298元\n"
                f"• 高端款：358-588元\n\n"
                f"支持批量购买优惠，具体价格请查看商品详情 👇"
            )
        elif "库存" in message.text or "有货" in message.text:
            return (
                f"📦 库存情况\n\n"
                f"我们保持充足的库存，大部分商品现货供应。\n"
                f"如遇特殊情况缺货，会及时通知并推荐替代产品。\n\n"
                f"查看实时库存状态 👇"
            )
        else:
            return (
                f"👋 感谢咨询 {merchant.merchant_name}！\n\n"
                f"我们专业提供高品质电子烟产品，"
                f"覆盖{merchant.region_name}地区配送。\n\n"
                f"📞 如需详细咨询，请联系我们的专业客服团队。"
            )
    
    async def _get_merchant_by_user_id(self, user_id: int):
        """根据用户ID获取商家信息"""
        result = await self.db.execute(
            "SELECT * FROM merchants WHERE user_id = :user_id AND status = 'active'",
            {"user_id": user_id}
        )
        return result.fetchone()
    
    async def _get_merchant_by_business_connection(self, connection_id: str):
        """根据Business连接ID获取商家"""
        result = await self.db.execute(
            "SELECT * FROM merchants WHERE business_connection_id = :conn_id",
            {"conn_id": connection_id}
        )
        return result.fetchone()

# handlers/business.py - Business Account处理器
from aiogram import Router, F
from aiogram.types import BusinessConnection, Message, BusinessMessagesDeleted

business_router = Router()

@business_router.business_connection()
async def handle_business_connection(business_connection: BusinessConnection, bot, db_session):
    """处理Business Account连接/断开"""
    manager = BusinessAccountManager(bot, db_session)
    await manager.handle_business_connection(business_connection)

@business_router.business_message()
async def handle_business_message(message: Message, business_connection_id: str, bot, db_session):
    """处理Business Account消息"""
    manager = BusinessAccountManager(bot, db_session)
    await manager.handle_business_message(message, business_connection_id)

@business_router.message(F.business_messages_deleted)
async def handle_business_messages_deleted(deleted_messages: BusinessMessagesDeleted):
    """处理Business消息删除事件"""
    logger.info("Business messages deleted", 
               connection_id=deleted_messages.business_connection_id,
               message_count=len(deleted_messages.message_ids))
```

#### 状态机设计（增强版）

```python
# fsm/states.py - 用户状态定义（扩展版）
from aiogram.fsm.state import State, StatesGroup
from enum import Enum

class UserRole(Enum):
    """用户角色枚举"""
    CUSTOMER = "customer"       # 普通用户
    MERCHANT = "merchant"       # 商家
    ADMIN = "admin"            # 管理员
    SUPPORT = "support"        # 客服

# 用户基础状态
class UserStates(StatesGroup):
    # 无感注册流程 (基于Telegram用户身份)
    registration_welcome = State()         # 欢迎新用户
    registration_location = State()        # 位置设置
    registration_age_verify = State()      # 年龄验证
    registration_complete = State()        # 注册完成
    
    # 主要业务状态
    browsing_products = State()            # 浏览商品
    product_detail = State()               # 商品详情
    cart_management = State()              # 购物车管理
    checkout_process = State()             # 结账流程
    order_tracking = State()               # 订单跟踪
    
    # 客服相关状态
    customer_service = State()             # 客服对话
    complaint_process = State()            # 投诉处理
    feedback_collection = State()          # 反馈收集

# 商家状态
class MerchantStates(StatesGroup):
    # 简化商家入驻
    merchant_registration_start = State()     # 开始入驻
    region_selection = State()                # 地区选择
    payment_confirmation = State()            # 确认支付
    payment_waiting = State()                 # 等待支付确认
    business_account_setup = State()          # Business Account设置
    bot_authorization = State()               # Bot授权
    registration_complete = State()           # 入驻完成
    
    # 商品管理
    product_add = State()                     # 添加商品
    product_edit = State()                    # 编辑商品
    product_upload_images = State()           # 上传商品图片
    product_set_inventory = State()           # 设置库存
    
    # 订单管理
    order_process = State()                   # 处理订单
    order_shipment = State()                  # 发货状态
    order_customer_service = State()          # 客服处理
    
    # Business Account专用状态
    business_setup = State()                  # Business功能设置
    business_auto_reply_config = State()      # 自动回复配置
    business_notification_config = State()    # 通知设置
    
    # 消息转发状态
    message_forwarding = State()              # 消息转发模式
    customer_communication = State()          # 与客户沟通

# 配送员状态
class DeliveryStates(StatesGroup):
    # 配送管理
    delivery_menu = State()                # 配送主菜单
    order_list = State()                   # 订单列表
    order_detail = State()                 # 订单详情
    delivery_update = State()              # 配送状态更新
    
    # 与用户沟通 (通过Bot转发)
    customer_contact = State()             # 联系客户
    location_sharing = State()             # 位置分享
    delivery_confirmation = State()        # 配送确认

# 管理员状态
class AdminStates(StatesGroup):
    # 平台管理
    merchant_review = State()              # 商家审核
    product_moderation = State()           # 商品审核
    user_management = State()              # 用户管理
    
    # 数据分析
    analytics_view = State()               # 数据分析
    report_generation = State()            # 报告生成
    
    # 系统配置
    system_config = State()                # 系统配置
    region_management = State()            # 地区管理

# fsm/advanced_fsm.py - 高级状态机管理器
import asyncio
from typing import Dict, Any, Optional, List
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
import structlog
import json
from datetime import datetime, timedelta

logger = structlog.get_logger()

class AdvancedFSMManager:
    """高级状态机管理器"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.state_history_ttl = 86400 * 7  # 7天
        self.auto_timeout_states = {
            # 定义需要自动超时的状态和超时时间（秒）
            UserStates.registration_location: 600,         # 10分钟
            UserStates.checkout_process: 1800,             # 30分钟
            MerchantStates.product_upload_images: 600,     # 10分钟
            AdminStates.merchant_review: 86400,            # 24小时
        }
    
    async def set_state_with_data(self, 
                                  state_context: FSMContext,
                                  new_state: State,
                                  data: Dict[str, Any] = None,
                                  timeout: Optional[int] = None):
        """设置状态并保存数据，支持超时"""
        try:
            # 记录状态变更历史
            await self._record_state_history(state_context, new_state)
            
            # 设置新状态
            await state_context.set_state(new_state)
            
            # 保存状态数据
            if data:
                await state_context.update_data(**data)
            
            # 设置自动超时
            timeout = timeout or self.auto_timeout_states.get(new_state)
            if timeout:
                await self._set_state_timeout(state_context, new_state, timeout)
            
            logger.info("State changed", 
                       new_state=new_state.state, 
                       data_keys=list(data.keys()) if data else [],
                       timeout=timeout)
                       
        except Exception as e:
            logger.error("Failed to set state", error=str(e))
    
    async def _record_state_history(self, state_context: FSMContext, new_state: State):
        """记录状态变更历史"""
        try:
            user_id = await self._get_user_id_from_context(state_context)
            if not user_id:
                return
            
            history_key = f"state_history:{user_id}"
            
            # 获取当前状态
            current_state = await state_context.get_state()
            
            # 构建历史记录
            history_entry = {
                "from_state": current_state,
                "to_state": new_state.state,
                "timestamp": datetime.now().isoformat(),
                "user_id": user_id
            }
            
            # 保存到Redis（使用列表，最新的在前面）
            await self.redis.lpush(history_key, json.dumps(history_entry))
            await self.redis.ltrim(history_key, 0, 99)  # 保留最新100条
            await self.redis.expire(history_key, self.state_history_ttl)
            
        except Exception as e:
            logger.error("Failed to record state history", error=str(e))
    
    async def _set_state_timeout(self, state_context: FSMContext, state: State, timeout: int):
        """设置状态超时"""
        try:
            user_id = await self._get_user_id_from_context(state_context)
            if not user_id:
                return
            
            timeout_key = f"state_timeout:{user_id}:{state.state}"
            timeout_data = {
                "user_id": user_id,
                "state": state.state,
                "expires_at": (datetime.now() + timedelta(seconds=timeout)).isoformat()
            }
            
            await self.redis.setex(timeout_key, timeout, json.dumps(timeout_data))
            
            # 启动超时检查任务
            asyncio.create_task(self._handle_state_timeout(timeout_key, timeout))
            
        except Exception as e:
            logger.error("Failed to set state timeout", error=str(e))
    
    async def _handle_state_timeout(self, timeout_key: str, delay: int):
        """处理状态超时"""
        try:
            await asyncio.sleep(delay)
            
            # 检查超时键是否还存在
            timeout_data = await self.redis.get(timeout_key)
            if not timeout_data:
                return  # 已被清除，说明状态已正常变更
            
            data = json.loads(timeout_data)
            user_id = data["user_id"]
            expired_state = data["state"]
            
            # 执行超时处理逻辑
            await self._execute_timeout_action(user_id, expired_state)
            
            # 清除超时键
            await self.redis.delete(timeout_key)
            
        except Exception as e:
            logger.error("Failed to handle state timeout", timeout_key=timeout_key, error=str(e))
    
    async def _execute_timeout_action(self, user_id: int, expired_state: str):
        """执行超时动作"""
        try:
            if expired_state == UserStates.registration_location.state:
                # 位置设置超时，提醒用户完成设置
                await self._send_timeout_message(user_id, 
                    "⏰ 位置设置时间过长，请重新设置您的位置信息")
                    
            elif expired_state == UserStates.checkout_process.state:
                # 结账超时，清空购物车
                await self._send_timeout_message(user_id,
                    "⏰ 结账超时，购物车已清空，请重新选择商品")
                    
            elif expired_state == MerchantStates.product_upload_images.state:
                # 图片上传超时
                await self._send_timeout_message(user_id,
                    "⏰ 图片上传超时，请重新操作")
                    
            # 重置到默认状态
            # 注意：这里需要获取实际的FSMContext，在真实实现中需要通过Bot API
            
        except Exception as e:
            logger.error("Failed to execute timeout action", user_id=user_id, error=str(e))
    
    async def get_state_history(self, user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
        """获取用户状态历史"""
        try:
            history_key = f"state_history:{user_id}"
            history_data = await self.redis.lrange(history_key, 0, limit - 1)
            
            return [json.loads(entry) for entry in history_data]
            
        except Exception as e:
            logger.error("Failed to get state history", user_id=user_id, error=str(e))
            return []
    
    async def clear_state_timeout(self, state_context: FSMContext, state: State):
        """清除状态超时"""
        try:
            user_id = await self._get_user_id_from_context(state_context)
            if not user_id:
                return
            
            timeout_key = f"state_timeout:{user_id}:{state.state}"
            await self.redis.delete(timeout_key)
            
        except Exception as e:
            logger.error("Failed to clear state timeout", error=str(e))
    
    async def _get_user_id_from_context(self, state_context: FSMContext) -> Optional[int]:
        """从状态上下文获取用户ID"""
        try:
            # 这里需要根据实际的FSMContext实现来获取用户ID
            # 通常可以通过state_context.key获取
            return getattr(state_context, 'user_id', None)
        except:
            return None
    
    async def _send_timeout_message(self, user_id: int, message: str):
        """发送超时消息（需要Bot实例）"""
        # 这里需要实际的Bot实例来发送消息
        # 在真实实现中，可以通过依赖注入或全局变量获取Bot
        logger.info("Timeout message", user_id=user_id, message=message)

# fsm/workflow_engine.py - 工作流引擎
from typing import Dict, List, Callable, Any
from dataclasses import dataclass
from enum import Enum

class WorkflowAction(Enum):
    """工作流动作类型"""
    SEND_MESSAGE = "send_message"
    UPDATE_DATA = "update_data"
    CALL_API = "call_api"
    NOTIFY_ADMIN = "notify_admin"
    LOG_EVENT = "log_event"
    CREATE_INVOICE = "create_invoice"
    CHECK_BUSINESS_ACCOUNT = "check_business_account"
    SETUP_BUSINESS_RIGHTS = "setup_business_rights"
    GENERATE_PAYMENT_ADDRESS = "generate_payment_address"
    MONITOR_PAYMENT = "monitor_payment"
    CHECK_BUSINESS_ACCOUNT = "check_business_account"
    SETUP_BUSINESS_RIGHTS = "setup_business_rights"

@dataclass
class WorkflowStep:
    """工作流步骤定义"""
    step_id: str
    state: State
    condition: Optional[Callable] = None
    actions: List[Dict[str, Any]] = None
    next_steps: List[str] = None
    timeout: Optional[int] = None

class WorkflowEngine:
    """业务工作流引擎"""
    
    def __init__(self, fsm_manager: AdvancedFSMManager):
        self.fsm_manager = fsm_manager
        self.workflows = {}
        self._setup_default_workflows()
    
    def _setup_default_workflows(self):
        """设置默认工作流"""
        
        # 用户无感注册工作流
        self.workflows['user_registration'] = [
            WorkflowStep(
                step_id="welcome_new_user",
                state=UserStates.registration_welcome,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "🎉 欢迎使用电子烟购物平台！\n\n"
                             "我们已为您自动创建账户，现在需要简单设置："
                }],
                next_steps=["set_location"],
                timeout=300
            ),
            WorkflowStep(
                step_id="set_location",
                state=UserStates.registration_location,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "📍 请分享您的位置或输入所在城市\n"
                             "这将帮助我们为您推荐附近的商家和商品"
                }],
                next_steps=["complete_registration"]
            ),
            WorkflowStep(
                step_id="complete_registration",
                state=UserStates.registration_complete,
                actions=[
                    {
                        "type": WorkflowAction.SEND_MESSAGE,
                        "message": "🎉 设置完成！欢迎使用本平台\n\n"
                                 "💬 所有交流都将通过Bot进行\n"
                                 "📦 订单和配送信息会及时推送\n"
                                 "🔔 重要通知会第一时间告知您"
                    },
                    {
                        "type": WorkflowAction.UPDATE_DATA,
                        "data": {"registration_completed": True, "auto_registered": True}
                    },
                    {
                        "type": WorkflowAction.LOG_EVENT,
                        "event": "user_auto_registered"
                    }
                ]
            )
        ]
        
        # 简化商家入驻工作流
        self.workflows['merchant_onboarding'] = [
            WorkflowStep(
                step_id="start_registration",
                state=MerchantStates.merchant_registration_start,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "🏪 商家入驻申请\n\n"
                             "✅ 无需营业执照\n"
                             "✅ 无需店铺名称\n"
                             "✅ 选择经营地区即可\n\n"
                             "点击下方按钮开始："
                }],
                next_steps=["select_region"]
            ),
            WorkflowStep(
                step_id="select_region",
                state=MerchantStates.region_selection,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "🌍 请选择您的经营地区：\n\n"
                             "1. 从下拉列表选择国家/地区\n"
                             "2. 或直接输入地区名称\n\n"
                             "注意：地区选择后不可更改"
                }],
                next_steps=["confirm_payment"],
                timeout=300
            ),
            WorkflowStep(
                step_id="confirm_payment",
                state=MerchantStates.payment_confirmation,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "💰 费用明细：\n\n"
                             "🔐 保证金：$1000等值加密货币 (一次性)\n"
                             "🏠 月租金：{{region_rent}}$ (月付)\n\n"
                             "支持币种：BTC、ETH、USDT(TRC20/ERC20)、TRX\n"
                             "支付后立即开通，无需等待审核"
                }, {
                    "type": WorkflowAction.GENERATE_PAYMENT_ADDRESS,
                    "payment_data": {
                        "amount_usd": "{{total_amount}}",
                        "purpose": "merchant_registration",
                        "user_id": "{{user_id}}",
                        "admin_payment_config": "{{selected_currency}}"
                    }
                }],
                next_steps=["wait_payment_confirmation"],
                timeout=1800
            ),
            WorkflowStep(
                step_id="wait_payment_confirmation",
                state=MerchantStates.payment_waiting,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "⏳ 等待支付确认...\n\n"
                             "收款地址：{{payment_address}}\n"
                             "支付金额：{{crypto_amount}} {{currency}}\n"
                             "网络：{{network}}\n\n"
                             "⚠️ 请准确转账，金额不足将无法自动确认\n"
                             "💡 支付完成后系统将自动检测到账"
                }],
                next_steps=["setup_business_account"],
                auto_trigger_on="payment_confirmed"
            ),
            WorkflowStep(
                step_id="setup_business_account",
                state=MerchantStates.business_account_setup,
                actions=[{
                    "type": WorkflowAction.CHECK_BUSINESS_ACCOUNT,
                    "fallback_message": "📱 请按以下步骤设置Business Account：\n\n"
                                      "1. 点击链接创建Business Account\n"
                                      "2. 设置您的商家信息\n"
                                      "3. 返回此处继续授权"
                }],
                next_steps=["authorize_bot"],
                timeout=600
            ),
            WorkflowStep(
                step_id="authorize_bot",
                state=MerchantStates.bot_authorization,
                actions=[{
                    "type": WorkflowAction.SEND_MESSAGE,
                    "message": "🤖 最后一步：授权Bot管理权限\n\n"
                             "点击下方链接完成授权：\n"
                             "{{auth_deep_link}}\n\n"
                             "授权后将自动完成开通"
                }],
                next_steps=["complete_registration"],
                timeout=300
            ),
            WorkflowStep(
                step_id="complete_registration",
                state=MerchantStates.registration_complete,
                actions=[
                    {
                        "type": WorkflowAction.SEND_MESSAGE,
                        "message": "🎉 商家入驻成功！\n\n"
                                 "✅ 支付已完成\n"
                                 "✅ Business Account已连接\n"
                                 "✅ 地区权限已开通\n"
                                 "✅ Bot管理权限已配置\n\n"
                                 "现在您可以：\n"
                                 "📦 添加商品\n"
                                 "📋 管理订单\n"
                                 "💬 与客户沟通\n"
                                 "📊 查看销售数据"
                    },
                    {
                        "type": WorkflowAction.UPDATE_DATA,
                        "data": {"merchant_verified": True, "auto_approved": True}
                    },
                    {
                        "type": WorkflowAction.SETUP_BUSINESS_RIGHTS,
                        "rights": ["can_reply", "can_read_messages", "can_edit_name", "can_edit_bio"]
                    },
                    {
                        "type": WorkflowAction.LOG_EVENT,
                        "event": "merchant_auto_registered"
                    }
                ]
            )
                    {
                        "type": WorkflowAction.NOTIFY_ADMIN,
                        "message": "新商家申请需要审核"
                    }
                ],
                timeout=86400
            )
        ]
    
    async def execute_workflow(self, workflow_name: str, context: FSMContext, step_id: str = None):
        """执行工作流"""
        try:
            workflow = self.workflows.get(workflow_name)
            if not workflow:
                logger.error("Workflow not found", workflow=workflow_name)
                return
            
            # 找到起始步骤
            if step_id:
                step = next((s for s in workflow if s.step_id == step_id), None)
            else:
                step = workflow[0]
            
            if not step:
                logger.error("Workflow step not found", workflow=workflow_name, step=step_id)
                return
            
            # 执行步骤
            await self._execute_workflow_step(step, context)
            
        except Exception as e:
            logger.error("Failed to execute workflow", 
                        workflow=workflow_name, step=step_id, error=str(e))
    
    async def _execute_workflow_step(self, step: WorkflowStep, context: FSMContext):
        """执行工作流步骤"""
        try:
            # 检查条件
            if step.condition and not await step.condition(context):
                logger.info("Workflow step condition not met", step=step.step_id)
                return
            
            # 设置状态
            await self.fsm_manager.set_state_with_data(
                context, step.state, timeout=step.timeout
            )
            
            # 执行动作
            if step.actions:
                for action in step.actions:
                    await self._execute_action(action, context)
            
            logger.info("Workflow step executed", step=step.step_id, state=step.state.state)
            
        except Exception as e:
            logger.error("Failed to execute workflow step", step=step.step_id, error=str(e))
    
    async def _execute_action(self, action: Dict[str, Any], context: FSMContext):
        """执行工作流动作"""
        action_type = WorkflowAction(action["type"])
        
        if action_type == WorkflowAction.SEND_MESSAGE:
            # 发送消息（需要Bot实例）
            logger.info("Would send message", message=action["message"])
            
        elif action_type == WorkflowAction.UPDATE_DATA:
            # 更新状态数据
            await context.update_data(**action["data"])
            
        elif action_type == WorkflowAction.LOG_EVENT:
            # 记录事件
            logger.info("Workflow event", event=action["event"])
            
        elif action_type == WorkflowAction.NOTIFY_ADMIN:
            # 通知管理员
            logger.info("Would notify admin", message=action["message"])
```

#### 异步消息队列系统

```python
# queue/message_queue.py - 异步消息队列管理
import asyncio
import json
import uuid
from typing import Dict, Any, Optional, Callable, List
from datetime import datetime, timedelta
from enum import Enum
import structlog

logger = structlog.get_logger()

class MessagePriority(Enum):
    """消息优先级"""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4

class QueueType(Enum):
    """队列类型"""
    NOTIFICATION = "notification"      # 通知队列
    ORDER_PROCESSING = "order_proc"    # 订单处理
    IMAGE_PROCESSING = "image_proc"    # 图片处理
    ANALYTICS = "analytics"            # 数据分析
    MESSAGE_FORWARD = "msg_forward"    # 消息转发
    WEBHOOK = "webhook"               # Webhook回调

class AsyncMessageQueue:
    """异步消息队列系统"""
    
    def __init__(self, redis_client, max_retries: int = 3):
        self.redis = redis_client
        self.max_retries = max_retries
        self.consumers = {}
        self.running = False
        self.consumer_tasks = []
        
        # 队列配置
        self.queue_configs = {
            QueueType.NOTIFICATION: {
                "max_workers": 5,
                "retry_delay": 60,
                "max_size": 10000
            },
            QueueType.ORDER_PROCESSING: {
                "max_workers": 3,
                "retry_delay": 30,
                "max_size": 5000
            },
            QueueType.IMAGE_PROCESSING: {
                "max_workers": 2,
                "retry_delay": 120,
                "max_size": 1000
            },
            QueueType.ANALYTICS: {
                "max_workers": 1,
                "retry_delay": 300,
                "max_size": 50000
            },
            QueueType.MESSAGE_FORWARD: {
                "max_workers": 4,
                "retry_delay": 30,
                "max_size": 20000
            },
            QueueType.WEBHOOK: {
                "max_workers": 3,
                "retry_delay": 60,
                "max_size": 5000
            }
        }
    
    async def publish(self, 
                     queue_type: QueueType, 
                     message_data: Dict[str, Any],
                     priority: MessagePriority = MessagePriority.NORMAL,
                     delay: Optional[int] = None,
                     unique_key: Optional[str] = None) -> str:
        """发布消息到队列"""
        try:
            message_id = str(uuid.uuid4())
            
            # 构建消息
            message = {
                "id": message_id,
                "queue_type": queue_type.value,
                "data": message_data,
                "priority": priority.value,
                "created_at": datetime.now().isoformat(),
                "retry_count": 0,
                "unique_key": unique_key
            }
            
            # 检查唯一性
            if unique_key:
                existing = await self._check_duplicate_message(queue_type, unique_key)
                if existing:
                    logger.info("Duplicate message ignored", 
                               queue=queue_type.value, unique_key=unique_key)
                    return existing
            
            # 延迟消息处理
            if delay:
                await self._schedule_delayed_message(message, delay)
            else:
                await self._add_to_queue(queue_type, message)
            
            logger.info("Message published", 
                       queue=queue_type.value, 
                       message_id=message_id,
                       priority=priority.value,
                       delay=delay)
            
            return message_id
            
        except Exception as e:
            logger.error("Failed to publish message", 
                        queue=queue_type.value, error=str(e))
            raise
    
    async def _add_to_queue(self, queue_type: QueueType, message: Dict[str, Any]):
        """添加消息到队列"""
        queue_key = f"queue:{queue_type.value}"
        priority_score = message["priority"] * 1000000 + int(datetime.now().timestamp())
        
        # 使用Redis有序集合实现优先级队列
        await self.redis.zadd(queue_key, {json.dumps(message): priority_score})
        
        # 检查队列大小限制
        config = self.queue_configs[queue_type]
        queue_size = await self.redis.zcard(queue_key)
        if queue_size > config["max_size"]:
            # 移除最老的低优先级消息
            await self.redis.zremrangebyrank(queue_key, 0, queue_size - config["max_size"])
    
    async def _schedule_delayed_message(self, message: Dict[str, Any], delay: int):
        """安排延迟消息"""
        execute_at = datetime.now() + timedelta(seconds=delay)
        delayed_key = "delayed_messages"
        
        delayed_message = {
            **message,
            "execute_at": execute_at.isoformat()
        }
        
        score = int(execute_at.timestamp())
        await self.redis.zadd(delayed_key, {json.dumps(delayed_message): score})
    
    async def _check_duplicate_message(self, queue_type: QueueType, unique_key: str) -> Optional[str]:
        """检查重复消息"""
        duplicate_key = f"unique:{queue_type.value}:{unique_key}"
        existing_id = await self.redis.get(duplicate_key)
        return existing_id.decode() if existing_id else None
    
    def register_consumer(self, queue_type: QueueType, handler: Callable):
        """注册消息消费者"""
        self.consumers[queue_type] = handler
        logger.info("Consumer registered", queue=queue_type.value)
    
    async def start_consumers(self):
        """启动所有消费者"""
        if self.running:
            return
        
        self.running = True
        
        # 启动延迟消息处理器
        self.consumer_tasks.append(
            asyncio.create_task(self._process_delayed_messages())
        )
        
        # 为每个队列启动消费者
        for queue_type, handler in self.consumers.items():
            config = self.queue_configs[queue_type]
            for i in range(config["max_workers"]):
                task = asyncio.create_task(
                    self._consume_messages(queue_type, handler, f"worker-{i}")
                )
                self.consumer_tasks.append(task)
        
        logger.info("All consumers started", 
                   total_workers=len(self.consumer_tasks))
    
    async def stop_consumers(self):
        """停止所有消费者"""
        self.running = False
        
        # 等待所有任务完成
        if self.consumer_tasks:
            await asyncio.gather(*self.consumer_tasks, return_exceptions=True)
            self.consumer_tasks.clear()
        
        logger.info("All consumers stopped")
    
    async def _consume_messages(self, queue_type: QueueType, handler: Callable, worker_id: str):
        """消费消息"""
        queue_key = f"queue:{queue_type.value}"
        processing_key = f"processing:{queue_type.value}:{worker_id}"
        
        while self.running:
            try:
                # 从队列获取最高优先级消息
                result = await self.redis.zpopmax(queue_key, count=1)
                
                if not result:
                    await asyncio.sleep(1)  # 队列为空，等待
                    continue
                
                message_data, score = result[0]
                message = json.loads(message_data)
                
                # 移动到处理中队列
                await self.redis.setex(processing_key, 300, message_data)  # 5分钟超时
                
                # 处理消息
                success = await self._handle_message(message, handler, queue_type)
                
                if success:
                    # 处理成功，清除处理中标记
                    await self.redis.delete(processing_key)
                    
                    # 清除唯一性标记
                    if message.get("unique_key"):
                        unique_key = f"unique:{queue_type.value}:{message['unique_key']}"
                        await self.redis.delete(unique_key)
                else:
                    # 处理失败，重新入队或移到失败队列
                    await self._handle_failed_message(message, queue_type)
                    await self.redis.delete(processing_key)
                
            except Exception as e:
                logger.error("Consumer error", 
                           queue=queue_type.value, 
                           worker=worker_id, 
                           error=str(e))
                await asyncio.sleep(5)
    
    async def _handle_message(self, message: Dict[str, Any], handler: Callable, queue_type: QueueType) -> bool:
        """处理单个消息"""
        try:
            logger.info("Processing message", 
                       queue=queue_type.value,
                       message_id=message["id"])
            
            # 调用处理器
            result = await handler(message["data"])
            
            if result:
                logger.info("Message processed successfully",
                           queue=queue_type.value,
                           message_id=message["id"])
                return True
            else:
                logger.warning("Message processing returned False",
                              queue=queue_type.value,
                              message_id=message["id"])
                return False
                
        except Exception as e:
            logger.error("Message processing failed",
                        queue=queue_type.value,
                        message_id=message["id"],
                        error=str(e))
            return False
    
    async def _handle_failed_message(self, message: Dict[str, Any], queue_type: QueueType):
        """处理失败的消息"""
        retry_count = message.get("retry_count", 0)
        
        if retry_count < self.max_retries:
            # 增加重试次数
            message["retry_count"] = retry_count + 1
            
            # 计算延迟时间（指数退避）
            config = self.queue_configs[queue_type]
            delay = config["retry_delay"] * (2 ** retry_count)
            
            # 重新安排处理
            await self._schedule_delayed_message(message, delay)
            
            logger.info("Message scheduled for retry",
                       queue=queue_type.value,
                       message_id=message["id"],
                       retry_count=retry_count + 1,
                       delay=delay)
        else:
            # 超过最大重试次数，移到死信队列
            dead_letter_key = f"dead_letter:{queue_type.value}"
            await self.redis.lpush(dead_letter_key, json.dumps(message))
            await self.redis.ltrim(dead_letter_key, 0, 999)  # 保留最新1000条
            
            logger.error("Message moved to dead letter queue",
                        queue=queue_type.value,
                        message_id=message["id"],
                        retry_count=retry_count)
    
    async def _process_delayed_messages(self):
        """处理延迟消息"""
        while self.running:
            try:
                now = int(datetime.now().timestamp())
                
                # 获取到期的延迟消息
                messages = await self.redis.zrangebyscore(
                    "delayed_messages", 0, now, withscores=True
                )
                
                for message_data, score in messages:
                    message = json.loads(message_data)
                    queue_type = QueueType(message["queue_type"])
                    
                    # 移动到对应队列
                    await self._add_to_queue(queue_type, message)
                    
                    # 从延迟队列中移除
                    await self.redis.zrem("delayed_messages", message_data)
                    
                    logger.info("Delayed message moved to queue",
                               queue=queue_type.value,
                               message_id=message["id"])
                
                await asyncio.sleep(10)  # 每10秒检查一次
                
            except Exception as e:
                logger.error("Delayed message processing error", error=str(e))
                await asyncio.sleep(30)
    
    async def get_queue_stats(self) -> Dict[str, Any]:
        """获取队列统计信息"""
        stats = {}
        
        for queue_type in QueueType:
            queue_key = f"queue:{queue_type.value}"
            dead_letter_key = f"dead_letter:{queue_type.value}"
            
            stats[queue_type.value] = {
                "pending": await self.redis.zcard(queue_key),
                "dead_letter": await self.redis.llen(dead_letter_key),
                "workers": self.queue_configs[queue_type]["max_workers"]
            }
        
        # 延迟消息统计
        stats["delayed"] = await self.redis.zcard("delayed_messages")
        
        return stats

# queue/handlers.py - 消息处理器
import aiohttp
from PIL import Image
import io
import asyncio

class MessageHandlers:
    """消息处理器集合"""
    
    def __init__(self, bot, db_session):
        self.bot = bot
        self.db = db_session
    
    async def handle_notification(self, data: Dict[str, Any]) -> bool:
        """处理通知消息"""
        try:
            user_id = data["user_id"]
            message = data["message"]
            reply_markup = data.get("reply_markup")
            
            await self.bot.send_message(
                chat_id=user_id,
                text=message,
                reply_markup=reply_markup
            )
            return True
            
        except Exception as e:
            logger.error("Failed to send notification", error=str(e))
            return False
    
    async def handle_order_processing(self, data: Dict[str, Any]) -> bool:
        """处理订单处理消息"""
        try:
            order_id = data["order_id"]
            action = data["action"]
            
            if action == "payment_confirmed":
                await self._process_payment_confirmation(order_id)
            elif action == "prepare_shipment":
                await self._prepare_shipment(order_id)
            elif action == "update_inventory":
                await self._update_inventory(data["product_updates"])
            
            return True
            
        except Exception as e:
            logger.error("Failed to process order", order_id=order_id, error=str(e))
            return False
    
    async def handle_image_processing(self, data: Dict[str, Any]) -> bool:
        """处理图片处理消息"""
        try:
            image_url = data["image_url"]
            target_sizes = data.get("target_sizes", [(800, 600), (400, 300), (200, 150)])
            
            # 下载原图
            async with aiohttp.ClientSession() as session:
                async with session.get(image_url) as response:
                    if response.status != 200:
                        return False
                    
                    image_data = await response.read()
            
            # 处理图片
            processed_urls = await self._process_image_sizes(image_data, target_sizes)
            
            # 更新数据库
            await self._update_image_urls(data["product_id"], processed_urls)
            
            return True
            
        except Exception as e:
            logger.error("Failed to process image", error=str(e))
            return False
    
    async def handle_analytics(self, data: Dict[str, Any]) -> bool:
        """处理分析数据"""
        try:
            event_type = data["event_type"]
            event_data = data["event_data"]
            
            # 保存到分析数据表
            await self.db.execute(
                "INSERT INTO analytics_events (event_type, event_data, created_at) "
                "VALUES (:event_type, :event_data, NOW())",
                {"event_type": event_type, "event_data": json.dumps(event_data)}
            )
            await self.db.commit()
            
            return True
            
        except Exception as e:
            logger.error("Failed to process analytics", error=str(e))
            return False
    
    async def handle_message_forward(self, data: Dict[str, Any]) -> bool:
        """处理消息转发"""
        try:
            from_user_id = data["from_user_id"]
            to_user_id = data["to_user_id"]
            message_content = data["message_content"]
            message_type = data.get("message_type", "text")
            context = data.get("context", "")  # 配送、客服等上下文
            
            # 构建转发消息
            forward_text = f"📨 {context}消息转发:\n\n{message_content}"
            
            if message_type == "text":
                await self.bot.send_message(
                    chat_id=to_user_id,
                    text=forward_text
                )
            elif message_type == "photo":
                await self.bot.send_photo(
                    chat_id=to_user_id,
                    photo=data["file_id"],
                    caption=forward_text
                )
            elif message_type == "location":
                await self.bot.send_location(
                    chat_id=to_user_id,
                    latitude=data["latitude"],
                    longitude=data["longitude"]
                )
                await self.bot.send_message(
                    chat_id=to_user_id,
                    text=forward_text
                )
            
            # 记录转发日志
            await self.db.execute(
                "INSERT INTO message_forwards (from_user_id, to_user_id, content, context, created_at) "
                "VALUES (:from_id, :to_id, :content, :context, NOW())",
                {
                    "from_id": from_user_id,
                    "to_id": to_user_id,
                    "content": message_content,
                    "context": context
                }
            )
            await self.db.commit()
            
            return True
            
        except Exception as e:
            logger.error("Failed to forward message", error=str(e))
            return False
    
    async def handle_webhook(self, data: Dict[str, Any]) -> bool:
        """处理Webhook回调"""
        try:
            url = data["url"]
            method = data.get("method", "POST")
            payload = data["payload"]
            headers = data.get("headers", {})
            
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method=method,
                    url=url,
                    json=payload,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    return response.status < 400
            
        except Exception as e:
            logger.error("Failed to send webhook", error=str(e))
            return False
    
    async def _process_image_sizes(self, image_data: bytes, target_sizes: List[tuple]) -> List[str]:
        """处理图片尺寸"""
        processed_urls = []
        
        try:
            image = Image.open(io.BytesIO(image_data))
            
            for width, height in target_sizes:
                # 调整图片大小
                resized = image.resize((width, height), Image.Resampling.LANCZOS)
                
                # 保存处理后的图片
                output = io.BytesIO()
                resized.save(output, format='JPEG', quality=85)
                output.seek(0)
                
                # 上传到存储服务（这里需要实际的存储服务实现）
                url = await self._upload_processed_image(output.getvalue(), f"{width}x{height}")
                processed_urls.append(url)
            
            return processed_urls
            
        except Exception as e:
            logger.error("Failed to process image sizes", error=str(e))
            return []
```

#### 管理员收款地址配置系统

```python
# payment/admin_payment_config.py - 管理员收款地址配置系统
import json
from typing import Dict, List, Optional, Any
from enum import Enum
from dataclasses import dataclass
import structlog

logger = structlog.get_logger()

class SupportedCurrency(Enum):
    """支持的加密货币"""
    BTC = "bitcoin"
    ETH = "ethereum"
    USDT_TRC20 = "usdt_trc20"
    USDT_ERC20 = "usdt_erc20"
    TRX = "tron"
    
    @property
    def display_name(self) -> str:
        names = {
            "bitcoin": "比特币 (BTC)",
            "ethereum": "以太坊 (ETH)", 
            "usdt_trc20": "USDT (TRC20)",
            "usdt_erc20": "USDT (ERC20)",
            "tron": "波场币 (TRX)"
        }
        return names[self.value]
    
    @property
    def network(self) -> str:
        networks = {
            "bitcoin": "Bitcoin",
            "ethereum": "Ethereum",
            "usdt_trc20": "Tron",
            "usdt_erc20": "Ethereum", 
            "tron": "Tron"
        }
        return networks[self.value]

@dataclass
class PaymentAddress:
    """收款地址配置"""
    currency: SupportedCurrency
    address: str
    network: str
    is_active: bool = True
    priority: int = 1  # 优先级，数字越小优先级越高
    min_amount: float = 0.0
    confirmation_blocks: int = 1
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "currency": self.currency.value,
            "display_name": self.currency.display_name,
            "address": self.address,
            "network": self.network,
            "is_active": self.is_active,
            "priority": self.priority,
            "min_amount": self.min_amount,
            "confirmation_blocks": self.confirmation_blocks
        }

class AdminPaymentConfig:
    """管理员收款地址配置管理器"""
    
    def __init__(self, redis_client, db_session):
        self.redis = redis_client
        self.db = db_session
        self.config_key = "admin:payment_config"
        self.addresses_key = "admin:payment_addresses"
        
    async def set_payment_address(self, 
                                currency: SupportedCurrency, 
                                address: str,
                                priority: int = 1,
                                min_amount: float = 0.0) -> bool:
        """设置收款地址"""
        try:
            # 验证地址格式
            if not await self._validate_address(currency, address):
                logger.error("Invalid payment address", currency=currency.value, address=address)
                return False
            
            payment_addr = PaymentAddress(
                currency=currency,
                address=address,
                network=currency.network,
                priority=priority,
                min_amount=min_amount,
                confirmation_blocks=self._get_default_confirmations(currency)
            )
            
            # 保存到Redis
            config_data = await self.redis.hget(self.addresses_key, currency.value)
            if config_data:
                existing_config = json.loads(config_data)
                existing_config.update(payment_addr.to_dict())
            else:
                existing_config = payment_addr.to_dict()
            
            await self.redis.hset(
                self.addresses_key,
                currency.value,
                json.dumps(existing_config)
            )
            
            # 保存到数据库
            await self._save_to_database(payment_addr)
            
            logger.info("Payment address configured", 
                       currency=currency.value, 
                       address=address)
            return True
            
        except Exception as e:
            logger.error("Failed to set payment address", 
                        currency=currency.value, error=str(e))
            return False
    
    async def get_payment_address(self, currency: SupportedCurrency) -> Optional[PaymentAddress]:
        """获取指定币种的收款地址"""
        try:
            config_data = await self.redis.hget(self.addresses_key, currency.value)
            if not config_data:
                return None
            
            config = json.loads(config_data)
            return PaymentAddress(
                currency=currency,
                address=config["address"],
                network=config["network"],
                is_active=config.get("is_active", True),
                priority=config.get("priority", 1),
                min_amount=config.get("min_amount", 0.0),
                confirmation_blocks=config.get("confirmation_blocks", 1)
            )
            
        except Exception as e:
            logger.error("Failed to get payment address", 
                        currency=currency.value, error=str(e))
            return None
    
    async def get_all_payment_addresses(self) -> List[PaymentAddress]:
        """获取所有配置的收款地址"""
        try:
            all_configs = await self.redis.hgetall(self.addresses_key)
            addresses = []
            
            for currency_str, config_data in all_configs.items():
                try:
                    currency = SupportedCurrency(currency_str)
                    config = json.loads(config_data)
                    
                    if config.get("is_active", True):
                        addresses.append(PaymentAddress(
                            currency=currency,
                            address=config["address"],
                            network=config["network"],
                            is_active=config.get("is_active", True),
                            priority=config.get("priority", 1),
                            min_amount=config.get("min_amount", 0.0),
                            confirmation_blocks=config.get("confirmation_blocks", 1)
                        ))
                except (ValueError, KeyError, json.JSONDecodeError) as e:
                    logger.warning("Invalid payment config", 
                                 currency=currency_str, error=str(e))
                    continue
            
            # 按优先级排序
            addresses.sort(key=lambda x: x.priority)
            return addresses
            
        except Exception as e:
            logger.error("Failed to get all payment addresses", error=str(e))
            return []
    
    async def get_recommended_currency(self) -> Optional[SupportedCurrency]:
        """获取推荐的支付币种（优先级最高的）"""
        addresses = await self.get_all_payment_addresses()
        return addresses[0].currency if addresses else None
    
    async def disable_payment_address(self, currency: SupportedCurrency) -> bool:
        """禁用收款地址"""
        try:
            config_data = await self.redis.hget(self.addresses_key, currency.value)
            if not config_data:
                return False
            
            config = json.loads(config_data)
            config["is_active"] = False
            
            await self.redis.hset(
                self.addresses_key,
                currency.value,
                json.dumps(config)
            )
            
            logger.info("Payment address disabled", currency=currency.value)
            return True
            
        except Exception as e:
            logger.error("Failed to disable payment address", 
                        currency=currency.value, error=str(e))
            return False
    
    async def generate_payment_invoice(self, 
                                     amount_usd: float,
                                     currency: SupportedCurrency,
                                     purpose: str,
                                     user_id: int) -> Optional[Dict[str, Any]]:
        """生成支付发票"""
        try:
            payment_addr = await self.get_payment_address(currency)
            if not payment_addr:
                logger.error("No payment address configured", currency=currency.value)
                return None
            
            # 获取实时汇率
            crypto_amount = await self._convert_usd_to_crypto(amount_usd, currency)
            if not crypto_amount:
                return None
            
            # 生成唯一支付ID
            payment_id = await self._generate_payment_id(user_id, purpose)
            
            invoice_data = {
                "payment_id": payment_id,
                "currency": currency.value,
                "currency_display": currency.display_name,
                "network": payment_addr.network,
                "address": payment_addr.address,
                "amount_usd": amount_usd,
                "amount_crypto": crypto_amount,
                "confirmation_blocks": payment_addr.confirmation_blocks,
                "purpose": purpose,
                "user_id": user_id,
                "created_at": datetime.now().isoformat(),
                "expires_at": (datetime.now() + timedelta(minutes=30)).isoformat(),
                "status": "pending"
            }
            
            # 保存发票信息
            await self.redis.setex(
                f"payment_invoice:{payment_id}",
                1800,  # 30分钟过期
                json.dumps(invoice_data)
            )
            
            return invoice_data
            
        except Exception as e:
            logger.error("Failed to generate payment invoice", 
                        currency=currency.value, error=str(e))
            return None
    
    async def _validate_address(self, currency: SupportedCurrency, address: str) -> bool:
        """验证收款地址格式"""
        # 简化的地址验证，实际应用中需要更严格的验证
        address_patterns = {
            SupportedCurrency.BTC: {"length": [25, 35], "prefixes": ["1", "3", "bc1"]},
            SupportedCurrency.ETH: {"length": [42], "prefixes": ["0x"]},
            SupportedCurrency.USDT_ERC20: {"length": [42], "prefixes": ["0x"]},
            SupportedCurrency.USDT_TRC20: {"length": [34], "prefixes": ["T"]},
            SupportedCurrency.TRX: {"length": [34], "prefixes": ["T"]}
        }
        
        pattern = address_patterns.get(currency)
        if not pattern:
            return False
        
        # 检查长度
        if len(address) not in pattern["length"]:
            return False
        
        # 检查前缀
        if not any(address.startswith(prefix) for prefix in pattern["prefixes"]):
            return False
        
        return True
    
    def _get_default_confirmations(self, currency: SupportedCurrency) -> int:
        """获取默认确认区块数"""
        confirmations = {
            SupportedCurrency.BTC: 1,
            SupportedCurrency.ETH: 12,
            SupportedCurrency.USDT_ERC20: 12,
            SupportedCurrency.USDT_TRC20: 1,
            SupportedCurrency.TRX: 1
        }
        return confirmations.get(currency, 1)
    
    async def _convert_usd_to_crypto(self, amount_usd: float, currency: SupportedCurrency) -> Optional[float]:
        """将美元金额转换为加密货币金额"""
        try:
            # 这里应该调用实时汇率API
            # 为了示例，使用模拟汇率
            mock_rates = {
                SupportedCurrency.BTC: 45000.0,
                SupportedCurrency.ETH: 3000.0,
                SupportedCurrency.USDT_TRC20: 1.0,
                SupportedCurrency.USDT_ERC20: 1.0,
                SupportedCurrency.TRX: 0.08
            }
            
            rate = mock_rates.get(currency)
            if not rate:
                return None
            
            return round(amount_usd / rate, 8)
            
        except Exception as e:
            logger.error("Failed to convert USD to crypto", 
                        currency=currency.value, error=str(e))
            return None
    
    async def _generate_payment_id(self, user_id: int, purpose: str) -> str:
        """生成唯一支付ID"""
        import hashlib
        import time
        
        data = f"{user_id}:{purpose}:{time.time()}"
        return hashlib.md5(data.encode()).hexdigest()[:16]
    
    async def _save_to_database(self, payment_addr: PaymentAddress):
        """保存到数据库"""
        try:
            # 这里应该保存到数据库
            # 为了示例，只记录日志
            logger.info("Payment address saved to database", 
                       currency=payment_addr.currency.value)
        except Exception as e:
            logger.error("Failed to save to database", error=str(e))

# payment/payment_monitor.py - 支付监控系统
class PaymentMonitor:
    """支付到账监控系统"""
    
    def __init__(self, redis_client, admin_config: AdminPaymentConfig):
        self.redis = redis_client
        self.admin_config = admin_config
        self.monitoring_active = False
        
    async def start_monitoring(self):
        """开始监控支付"""
        if self.monitoring_active:
            return
        
        self.monitoring_active = True
        asyncio.create_task(self._monitor_payments())
        logger.info("Payment monitoring started")
    
    async def stop_monitoring(self):
        """停止监控支付"""
        self.monitoring_active = False
        logger.info("Payment monitoring stopped")
    
    async def _monitor_payments(self):
        """监控支付到账"""
        while self.monitoring_active:
            try:
                # 获取所有待确认的支付
                pending_payments = await self._get_pending_payments()
                
                for payment_id, payment_data in pending_payments.items():
                    await self._check_payment_status(payment_id, payment_data)
                
                await asyncio.sleep(30)  # 每30秒检查一次
                
            except Exception as e:
                logger.error("Payment monitoring error", error=str(e))
                await asyncio.sleep(60)
    
    async def _get_pending_payments(self) -> Dict[str, Dict]:
        """获取待确认的支付"""
        try:
            pattern = "payment_invoice:*"
            keys = await self.redis.keys(pattern)
            pending = {}
            
            for key in keys:
                payment_data = await self.redis.get(key)
                if payment_data:
                    data = json.loads(payment_data)
                    if data.get("status") == "pending":
                        payment_id = key.decode().split(":")[-1]
                        pending[payment_id] = data
            
            return pending
            
        except Exception as e:
            logger.error("Failed to get pending payments", error=str(e))
            return {}
    
    async def _check_payment_status(self, payment_id: str, payment_data: Dict):
        """检查具体支付状态"""
        try:
            currency = SupportedCurrency(payment_data["currency"])
            address = payment_data["address"]
            expected_amount = payment_data["amount_crypto"]
            
            # 这里应该调用区块链API检查到账情况
            # 为了示例，模拟检查逻辑
            confirmed = await self._mock_check_blockchain(currency, address, expected_amount)
            
            if confirmed:
                await self._confirm_payment(payment_id, payment_data)
                
        except Exception as e:
            logger.error("Failed to check payment status", 
                        payment_id=payment_id, error=str(e))
    
    async def _mock_check_blockchain(self, currency: SupportedCurrency, address: str, amount: float) -> bool:
        """模拟区块链检查（实际应用中需要对接真实的区块链API）"""
        # 这里应该实现真实的区块链查询逻辑
        return False
    
    async def _confirm_payment(self, payment_id: str, payment_data: Dict):
        """确认支付"""
        try:
            # 更新支付状态
            payment_data["status"] = "confirmed"
            payment_data["confirmed_at"] = datetime.now().isoformat()
            
            await self.redis.setex(
                f"payment_invoice:{payment_id}",
                86400,  # 24小时保留
                json.dumps(payment_data)
            )
            
            # 触发支付确认事件
            await self._trigger_payment_confirmed_event(payment_id, payment_data)
            
            logger.info("Payment confirmed", payment_id=payment_id)
            
        except Exception as e:
            logger.error("Failed to confirm payment", 
                        payment_id=payment_id, error=str(e))
    
    async def _trigger_payment_confirmed_event(self, payment_id: str, payment_data: Dict):
        """触发支付确认事件"""
        try:
            # 发布支付确认消息到队列
            event_data = {
                "event_type": "payment_confirmed",
                "payment_id": payment_id,
                "payment_data": payment_data
            }
            
            await self.redis.publish("payment_events", json.dumps(event_data))
            
        except Exception as e:
            logger.error("Failed to trigger payment event", error=str(e))
```

#### 性能监控和分析系统

```python
# monitoring/performance_monitor.py - 性能监控系统
import time
import psutil
import asyncio
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import structlog
from contextlib import asynccontextmanager

logger = structlog.get_logger()

@dataclass
class PerformanceMetric:
    """性能指标数据结构"""
    timestamp: datetime
    metric_name: str
    value: float
    unit: str
    tags: Dict[str, str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            **asdict(self),
            "timestamp": self.timestamp.isoformat()
        }

@dataclass
class RequestMetrics:
    """请求性能指标"""
    endpoint: str
    method: str
    duration: float
    status_code: int
    user_id: Optional[int] = None
    error: Optional[str] = None

class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self, redis_client, db_session):
        self.redis = redis_client
        self.db = db_session
        self.metrics_buffer = []
        self.buffer_size = 100
        self.flush_interval = 60  # 60秒
        self.monitoring_active = True
        
        # 性能阈值配置
        self.thresholds = {
            "response_time": 2.0,      # 响应时间超过2秒告警
            "memory_usage": 80.0,      # 内存使用率超过80%告警
            "cpu_usage": 80.0,         # CPU使用率超过80%告警
            "error_rate": 5.0,         # 错误率超过5%告警
            "queue_size": 1000,        # 队列大小超过1000告警
        }
        
        # 启动监控任务
        asyncio.create_task(self._start_system_monitoring())
        asyncio.create_task(self._flush_metrics_periodically())
    
    async def record_request_metric(self, metrics: RequestMetrics):
        """记录请求性能指标"""
        try:
            # 记录到缓冲区
            metric_data = {
                "type": "request",
                "timestamp": datetime.now().isoformat(),
                "endpoint": metrics.endpoint,
                "method": metrics.method,
                "duration": metrics.duration,
                "status_code": metrics.status_code,
                "user_id": metrics.user_id,
                "error": metrics.error
            }
            
            self.metrics_buffer.append(metric_data)
            
            # 检查是否超过响应时间阈值
            if metrics.duration > self.thresholds["response_time"]:
                await self._trigger_alert("slow_response", {
                    "endpoint": metrics.endpoint,
                    "duration": metrics.duration,
                    "threshold": self.thresholds["response_time"]
                })
            
            # 如果缓冲区满了，立即刷新
            if len(self.metrics_buffer) >= self.buffer_size:
                await self._flush_metrics()
                
        except Exception as e:
            logger.error("Failed to record request metric", error=str(e))
    
    @asynccontextmanager
    async def measure_request(self, endpoint: str, method: str = "POST", user_id: Optional[int] = None):
        """请求性能测量上下文管理器"""
        start_time = time.time()
        error = None
        status_code = 200
        
        try:
            yield
        except Exception as e:
            error = str(e)
            status_code = 500
            raise
        finally:
            duration = time.time() - start_time
            
            await self.record_request_metric(RequestMetrics(
                endpoint=endpoint,
                method=method,
                duration=duration,
                status_code=status_code,
                user_id=user_id,
                error=error
            ))
    
    async def record_custom_metric(self, name: str, value: float, unit: str = "", tags: Dict[str, str] = None):
        """记录自定义性能指标"""
        try:
            metric = PerformanceMetric(
                timestamp=datetime.now(),
                metric_name=name,
                value=value,
                unit=unit,
                tags=tags or {}
            )
            
            self.metrics_buffer.append({
                "type": "custom",
                **metric.to_dict()
            })
            
        except Exception as e:
            logger.error("Failed to record custom metric", metric=name, error=str(e))
    
    async def _start_system_monitoring(self):
        """启动系统资源监控"""
        while self.monitoring_active:
            try:
                # CPU使用率
                cpu_percent = psutil.cpu_percent(interval=1)
                await self.record_custom_metric("cpu_usage", cpu_percent, "percent")
                
                if cpu_percent > self.thresholds["cpu_usage"]:
                    await self._trigger_alert("high_cpu", {"value": cpu_percent})
                
                # 内存使用率
                memory = psutil.virtual_memory()
                memory_percent = memory.percent
                await self.record_custom_metric("memory_usage", memory_percent, "percent")
                await self.record_custom_metric("memory_available", memory.available / 1024 / 1024, "MB")
                
                if memory_percent > self.thresholds["memory_usage"]:
                    await self._trigger_alert("high_memory", {"value": memory_percent})
                
                # 磁盘使用率
                disk = psutil.disk_usage('/')
                disk_percent = (disk.used / disk.total) * 100
                await self.record_custom_metric("disk_usage", disk_percent, "percent")
                
                # 网络IO
                net_io = psutil.net_io_counters()
                await self.record_custom_metric("network_bytes_sent", net_io.bytes_sent, "bytes")
                await self.record_custom_metric("network_bytes_recv", net_io.bytes_recv, "bytes")
                
                # Redis连接数
                redis_info = await self.redis.info()
                await self.record_custom_metric("redis_connected_clients", 
                                               redis_info.get("connected_clients", 0), "count")
                await self.record_custom_metric("redis_used_memory", 
                                               redis_info.get("used_memory", 0), "bytes")
                
                await asyncio.sleep(30)  # 每30秒采集一次
                
            except Exception as e:
                logger.error("System monitoring error", error=str(e))
                await asyncio.sleep(60)
    
    async def _flush_metrics_periodically(self):
        """定期刷新指标到存储"""
        while self.monitoring_active:
            try:
                await asyncio.sleep(self.flush_interval)
                await self._flush_metrics()
            except Exception as e:
                logger.error("Metrics flush error", error=str(e))
    
    async def _flush_metrics(self):
        """刷新指标到数据库"""
        if not self.metrics_buffer:
            return
        
        try:
            # 批量插入到数据库
            for metric in self.metrics_buffer:
                await self.db.execute(
                    "INSERT INTO performance_metrics (metric_type, metric_data, created_at) "
                    "VALUES (:type, :data, NOW())",
                    {
                        "type": metric["type"],
                        "data": metric
                    }
                )
            
            await self.db.commit()
            
            # 同时存储到Redis（用于实时查询）
            pipeline = self.redis.pipeline()
            for metric in self.metrics_buffer:
                key = f"metrics:{metric['type']}:{datetime.now().strftime('%Y%m%d%H')}"
                pipeline.lpush(key, metric)
                pipeline.expire(key, 86400 * 7)  # 保留7天
            
            await pipeline.execute()
            
            logger.info("Metrics flushed", count=len(self.metrics_buffer))
            self.metrics_buffer.clear()
            
        except Exception as e:
            logger.error("Failed to flush metrics", error=str(e))
    
    async def _trigger_alert(self, alert_type: str, data: Dict[str, Any]):
        """触发告警"""
        try:
            alert_data = {
                "type": alert_type,
                "timestamp": datetime.now().isoformat(),
                "data": data,
                "severity": self._get_alert_severity(alert_type)
            }
            
            # 发送到告警队列
            await self.redis.lpush("alerts", alert_data)
            await self.redis.ltrim("alerts", 0, 999)  # 保留最新1000条告警
            
            logger.warning("Alert triggered", alert_type=alert_type, data=data)
            
        except Exception as e:
            logger.error("Failed to trigger alert", alert_type=alert_type, error=str(e))
    
    def _get_alert_severity(self, alert_type: str) -> str:
        """获取告警严重程度"""
        severity_map = {
            "slow_response": "warning",
            "high_cpu": "warning",
            "high_memory": "critical",
            "high_error_rate": "critical",
            "large_queue": "warning",
            "system_error": "critical"
        }
        return severity_map.get(alert_type, "info")
    
    async def get_performance_summary(self, hours: int = 24) -> Dict[str, Any]:
        """获取性能摘要"""
        try:
            start_time = datetime.now() - timedelta(hours=hours)
            
            # 从数据库查询指标
            result = await self.db.execute(
                "SELECT metric_type, metric_data FROM performance_metrics "
                "WHERE created_at >= :start_time ORDER BY created_at DESC",
                {"start_time": start_time}
            )
            
            metrics = result.fetchall()
            
            # 统计分析
            summary = {
                "period_hours": hours,
                "total_requests": 0,
                "avg_response_time": 0,
                "error_rate": 0,
                "peak_cpu_usage": 0,
                "peak_memory_usage": 0,
                "alerts_count": 0
            }
            
            request_times = []
            error_count = 0
            
            for metric in metrics:
                data = metric.metric_data
                
                if data["type"] == "request":
                    summary["total_requests"] += 1
                    request_times.append(data["duration"])
                    if data.get("error"):
                        error_count += 1
                
                elif data["type"] == "custom":
                    metric_name = data["metric_name"]
                    value = data["value"]
                    
                    if metric_name == "cpu_usage":
                        summary["peak_cpu_usage"] = max(summary["peak_cpu_usage"], value)
                    elif metric_name == "memory_usage":
                        summary["peak_memory_usage"] = max(summary["peak_memory_usage"], value)
            
            # 计算平均响应时间
            if request_times:
                summary["avg_response_time"] = sum(request_times) / len(request_times)
                summary["error_rate"] = (error_count / len(request_times)) * 100
            
            # 获取告警数量
            alerts = await self.redis.lrange("alerts", 0, -1)
            recent_alerts = [
                alert for alert in alerts 
                if datetime.fromisoformat(alert.get("timestamp", "1970-01-01")) >= start_time
            ]
            summary["alerts_count"] = len(recent_alerts)
            
            return summary
            
        except Exception as e:
            logger.error("Failed to get performance summary", error=str(e))
            return {}

# monitoring/analytics.py - 业务分析系统
from collections import defaultdict
from typing import Dict, List, Any, Tuple
import pandas as pd

class BusinessAnalytics:
    """业务数据分析系统"""
    
    def __init__(self, db_session, redis_client):
        self.db = db_session
        self.redis = redis_client
    
    async def track_user_behavior(self, user_id: int, action: str, data: Dict[str, Any] = None):
        """跟踪用户行为"""
        try:
            behavior_data = {
                "user_id": user_id,
                "action": action,
                "data": data or {},
                "timestamp": datetime.now().isoformat(),
                "session_id": await self._get_user_session_id(user_id)
            }
            
            # 存储到行为分析队列
            await self.redis.lpush("user_behaviors", behavior_data)
            await self.redis.ltrim("user_behaviors", 0, 99999)  # 保留最新10万条
            
            # 实时计数器更新
            today = datetime.now().strftime("%Y%m%d")
            hour = datetime.now().strftime("%Y%m%d%H")
            
            pipeline = self.redis.pipeline()
            
            # 日常统计
            pipeline.hincrby(f"daily_actions:{today}", action, 1)
            pipeline.hincrby(f"daily_users:{today}", user_id, 1)
            pipeline.expire(f"daily_actions:{today}", 86400 * 30)
            pipeline.expire(f"daily_users:{today}", 86400 * 30)
            
            # 小时统计
            pipeline.hincrby(f"hourly_actions:{hour}", action, 1)
            pipeline.expire(f"hourly_actions:{hour}", 86400 * 7)
            
            await pipeline.execute()
            
        except Exception as e:
            logger.error("Failed to track user behavior", 
                        user_id=user_id, action=action, error=str(e))
    
    async def generate_user_analytics_report(self, days: int = 7) -> Dict[str, Any]:
        """生成用户行为分析报告"""
        try:
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            # 查询用户行为数据
            result = await self.db.execute(
                """
                SELECT 
                    DATE(created_at) as date,
                    COUNT(DISTINCT user_id) as daily_active_users,
                    COUNT(*) as total_actions,
                    COUNT(CASE WHEN action = 'product_view' THEN 1 END) as product_views,
                    COUNT(CASE WHEN action = 'add_to_cart' THEN 1 END) as cart_additions,
                    COUNT(CASE WHEN action = 'purchase' THEN 1 END) as purchases
                FROM user_behaviors 
                WHERE created_at >= :start_date AND created_at <= :end_date
                GROUP BY DATE(created_at)
                ORDER BY date
                """,
                {"start_date": start_date, "end_date": end_date}
            )
            
            daily_data = result.fetchall()
            
            # 计算转化率
            conversion_funnel = await self._calculate_conversion_funnel(start_date, end_date)
            
            # 用户留存分析
            retention_data = await self._calculate_user_retention(days)
            
            # 热门商品分析
            popular_products = await self._get_popular_products(start_date, end_date)
            
            return {
                "period": f"{days} days",
                "daily_stats": [dict(row) for row in daily_data],
                "conversion_funnel": conversion_funnel,
                "retention_rates": retention_data,
                "popular_products": popular_products,
                "summary": {
                    "total_active_users": sum(row.daily_active_users for row in daily_data),
                    "total_actions": sum(row.total_actions for row in daily_data),
                    "avg_daily_users": sum(row.daily_active_users for row in daily_data) / len(daily_data) if daily_data else 0
                }
            }
            
        except Exception as e:
            logger.error("Failed to generate analytics report", error=str(e))
            return {}
    
    async def _calculate_conversion_funnel(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """计算转化漏斗"""
        try:
            # 查询各阶段用户数
            result = await self.db.execute(
                """
                WITH funnel_data AS (
                    SELECT user_id,
                           MAX(CASE WHEN action = 'product_view' THEN 1 ELSE 0 END) as viewed,
                           MAX(CASE WHEN action = 'add_to_cart' THEN 1 ELSE 0 END) as added_to_cart,
                           MAX(CASE WHEN action = 'checkout_start' THEN 1 ELSE 0 END) as started_checkout,
                           MAX(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END) as purchased
                    FROM user_behaviors
                    WHERE created_at >= :start_date AND created_at <= :end_date
                    GROUP BY user_id
                )
                SELECT 
                    SUM(viewed) as total_viewers,
                    SUM(added_to_cart) as total_cart_additions,
                    SUM(started_checkout) as total_checkout_starts,
                    SUM(purchased) as total_purchases
                FROM funnel_data
                """,
                {"start_date": start_date, "end_date": end_date}
            )
            
            row = result.fetchone()
            
            if not row.total_viewers:
                return {}
            
            return {
                "total_viewers": row.total_viewers,
                "cart_additions": row.total_cart_additions,
                "checkout_starts": row.total_checkout_starts,
                "purchases": row.total_purchases,
                "conversion_rates": {
                    "view_to_cart": (row.total_cart_additions / row.total_viewers) * 100,
                    "cart_to_checkout": (row.total_checkout_starts / row.total_cart_additions) * 100 if row.total_cart_additions else 0,
                    "checkout_to_purchase": (row.total_purchases / row.total_checkout_starts) * 100 if row.total_checkout_starts else 0,
                    "overall": (row.total_purchases / row.total_viewers) * 100
                }
            }
            
        except Exception as e:
            logger.error("Failed to calculate conversion funnel", error=str(e))
            return {}
    
    async def _calculate_user_retention(self, days: int) -> Dict[str, float]:
        """计算用户留存率"""
        try:
            # 计算每日留存率
            retention_rates = {}
            
            for day in range(1, min(days, 30) + 1):  # 最多计算30天留存
                result = await self.db.execute(
                    """
                    WITH first_visit AS (
                        SELECT user_id, MIN(DATE(created_at)) as first_date
                        FROM user_behaviors
                        GROUP BY user_id
                    ),
                    return_visits AS (
                        SELECT f.user_id
                        FROM first_visit f
                        JOIN user_behaviors b ON f.user_id = b.user_id
                        WHERE DATE(b.created_at) = DATE_ADD(f.first_date, INTERVAL :day DAY)
                    )
                    SELECT 
                        COUNT(DISTINCT f.user_id) as total_new_users,
                        COUNT(DISTINCT r.user_id) as returned_users
                    FROM first_visit f
                    LEFT JOIN return_visits r ON f.user_id = r.user_id
                    WHERE f.first_date <= DATE_SUB(CURDATE(), INTERVAL :day DAY)
                    """,
                    {"day": day}
                )
                
                row = result.fetchone()
                if row.total_new_users > 0:
                    retention_rates[f"day_{day}"] = (row.returned_users / row.total_new_users) * 100
                else:
                    retention_rates[f"day_{day}"] = 0
            
            return retention_rates
            
        except Exception as e:
            logger.error("Failed to calculate retention", error=str(e))
            return {}
```

## 8. 部署配置

### 8.1 Docker容器化部署

```yaml
# docker-compose.yml - 完整部署配置
version: '3.8'

services:
  telegram-bot:
    build: 
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - DATABASE_URL=postgresql://vapebot:${DB_PASSWORD}@postgres:5432/vapebot_db
      - REDIS_URL=redis://redis:6379/0
      - ENVIRONMENT=production
      - LOG_LEVEL=INFO
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads
    networks:
      - vapebot-network
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      - POSTGRES_DB=vapebot_db
      - POSTGRES_USER=vapebot
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - vapebot-network
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G

  redis:
    image: redis:6.2-alpine
    restart: unless-stopped
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - vapebot-network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.2'
          memory: 256M

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
      - ./uploads:/var/www/uploads
    depends_on:
      - telegram-bot
    networks:
      - vapebot-network

volumes:
  postgres_data:
  redis_data:

networks:
  vapebot-network:
    driver: bridge
```

```dockerfile
# Dockerfile - Bot应用容器
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    libjpeg-dev \
    libpng-dev \
    libwebp-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建必要目录
RUN mkdir -p logs uploads

# 设置权限
RUN useradd -m botuser && chown -R botuser:botuser /app
USER botuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import asyncio; asyncio.run(__import__('health_check').check())"

# 启动命令
CMD ["python", "main.py"]
```

```txt
# requirements.txt - Python依赖清单
aiogram==3.20.0
sqlmodel==0.0.24
asyncpg==0.29.0
redis==5.0.0
structlog==23.2.0
uvloop==0.19.0
aiofiles==23.2.1
aiohttp==3.9.0
Pillow==10.1.0
python-multipart==0.0.6
pydantic==2.5.0
pydantic-settings==2.1.0
psutil==5.9.6
pandas==2.1.4
cryptography==41.0.8
httpx==0.25.2
celery==5.3.4
flower==2.0.1
gunicorn==21.2.0
prometheus-client==0.19.0
```

### 8.2 生产环境配置

```python
# config/production.py - 生产环境配置
import os
from pydantic_settings import BaseSettings

class ProductionSettings(BaseSettings):
    """生产环境配置"""
    
    # Bot配置
    BOT_TOKEN: str
    BOT_USERNAME: str = "VapeStoreBot"
    
    # 数据库配置
    DATABASE_URL: str = "postgresql://vapebot:password@localhost:5432/vapebot_db"
    DB_POOL_SIZE: int = 20
    DB_MAX_OVERFLOW: int = 30
    DB_POOL_TIMEOUT: int = 30
    DB_POOL_RECYCLE: int = 3600
    
    # Redis配置
    REDIS_URL: str = "redis://localhost:6379/0"
    REDIS_MAX_CONNECTIONS: int = 50
    REDIS_RETRY_ON_TIMEOUT: bool = True
    
    # 安全配置
    SECRET_KEY: str
    ENCRYPTION_KEY: str
    JWT_SECRET: str
    WEBHOOK_SECRET: str
    
    # 文件存储
    UPLOAD_PATH: str = "/app/uploads"
    MAX_FILE_SIZE: int = 20 * 1024 * 1024  # 20MB
    ALLOWED_IMAGE_TYPES: list = ["image/jpeg", "image/png", "image/webp"]
    
    # 外部服务
    OSS_ACCESS_KEY: str = ""
    OSS_SECRET_KEY: str = ""
    OSS_BUCKET: str = ""
    
    # Bot特定配置
    BOT_MESSAGE_RETRY_COUNT: int = 3
    BOT_MESSAGE_TIMEOUT: int = 30
    MESSAGE_FORWARD_DELAY: int = 1  # 消息转发延迟(秒)
    
    # 性能配置
    MAX_WORKERS: int = 4
    RATE_LIMIT_PER_MINUTE: int = 60
    CACHE_TTL: int = 3600
    SESSION_TTL: int = 86400
    
    # 监控配置
    METRICS_ENABLED: bool = True
    LOG_LEVEL: str = "INFO"
    SENTRY_DSN: str = ""
    
    # 业务配置
    DEFAULT_REGION: str = "北京"
    MIN_ORDER_AMOUNT: float = 50.0
    MAX_ORDER_AMOUNT: float = 5000.0
    DELIVERY_FEE: float = 10.0
    FREE_DELIVERY_THRESHOLD: float = 200.0
    
    class Config:
        env_file = ".env"
        case_sensitive = True

# 部署脚本
# deploy.sh - 自动化部署脚本
#!/bin/bash

set -e

echo "🚀 开始部署 Telegram Vape Bot..."

# 检查环境变量
if [ -z "$BOT_TOKEN" ]; then
    echo "❌ 错误: BOT_TOKEN 环境变量未设置"
    exit 1
fi

if [ -z "$DB_PASSWORD" ]; then
    echo "❌ 错误: DB_PASSWORD 环境变量未设置"
    exit 1
fi

# 拉取最新代码
echo "📥 拉取最新代码..."
git pull origin main

# 构建镜像
echo "🔨 构建Docker镜像..."
docker-compose build --no-cache

# 数据库迁移
echo "🗄️ 执行数据库迁移..."
docker-compose run --rm telegram-bot python migrate.py

# 启动服务
echo "🚀 启动服务..."
docker-compose up -d

# 健康检查
echo "🏥 等待服务启动..."
sleep 30

# 检查服务状态
if docker-compose ps | grep -q "Up"; then
    echo "✅ 部署成功！"
    echo "📊 查看服务状态:"
    docker-compose ps
else
    echo "❌ 部署失败！"
    echo "📋 查看日志:"
    docker-compose logs
    exit 1
fi

echo "🎉 部署完成！"
```

### 8.3 监控和日志配置

```yaml
# monitoring/prometheus.yml - Prometheus监控配置
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'telegram-bot'
    static_configs:
      - targets: ['telegram-bot:8000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:9187']
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:9121']
    scrape_interval: 30s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

```yaml
# monitoring/alert_rules.yml - 告警规则
groups:
  - name: telegram-bot-alerts
    rules:
      - alert: HighResponseTime
        expr: avg_response_time > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Bot响应时间过高"
          description: "平均响应时间 {{ $value }}s 超过阈值"
      
      - alert: HighErrorRate
        expr: error_rate > 5
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "错误率过高"
          description: "错误率 {{ $value }}% 超过阈值"
      
      - alert: DatabaseConnectionIssue
        expr: postgres_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "数据库连接异常"
          description: "PostgreSQL数据库无法连接"
      
      - alert: RedisConnectionIssue
        expr: redis_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Redis连接异常"
          description: "Redis缓存服务无法连接"
```

## 9. 技术实现总结

### 9.1 核心技术栈优势

本项目采用的技术栈具有以下优势：

1. **aiogram 3.20.0**
   - ✅ 原生异步支持，高并发处理能力
   - ✅ 完整的中间件系统，便于功能扩展
   - ✅ 类型安全的API封装
   - ✅ 内置状态机支持
   - ✅ Business Account完整支持

2. **PostgreSQL 16+**
   - ✅ JSONB高性能文档存储
   - ✅ 全文搜索和向量搜索
   - ✅ 高级索引和查询优化
   - ✅ 事务隔离和ACID保证
   - ✅ 分区表和并行查询

3. **SQLModel 0.0.24**
   - ✅ 类型安全的ORM操作
   - ✅ Pydantic数据验证集成
   - ✅ 异步数据库操作支持
   - ✅ 自动API文档生成
   - ✅ FastAPI无缝集成

4. **Redis 6.2.0**
   - ✅ 高性能缓存和会话存储
   - ✅ 发布/订阅消息系统
   - ✅ 限流和防刷机制
   - ✅ 分布式锁支持
   - ✅ 持久化数据保护

### 9.2 架构特点

1. **高可用性设计**
   - 微服务架构，组件独立部署
   - 完整的错误处理和重试机制
   - 自动故障转移和恢复
   - 健康检查和监控告警

2. **高性能优化**
   - 异步非阻塞架构
   - 多级缓存策略
   - 数据库连接池优化
   - 图片压缩和CDN分发

3. **安全性保障**
   - 端到端数据加密
   - 访问控制和权限管理
   - 防刷和限流保护
   - 安全审计日志

4. **可扩展性**
   - 水平扩展支持
   - 插件化中间件系统
   - 模块化业务组件
   - 标准化API接口

### 9.3 业务功能完整性

1. **用户体验**
   - 智能商品推荐
   - 个性化购物体验
   - 多支付方式支持
   - 实时订单跟踪

2. **商家功能**
   - Business Account集成
   - 自动化运营工具
   - 数据分析报表
   - 客服系统支持

3. **管理功能**
   - 全面的后台管理
   - 实时监控面板
   - 数据分析报告
   - 系统配置管理

### 9.4 技术创新点

1. **Business Account深度集成**
   - 首次在电商Bot中完整实现Business Account功能
   - 自动消息转发和智能回复
   - 商家运营效率显著提升

2. **多级缓存架构**
   - Redis + 应用缓存 + 数据库缓存
   - 防穿透、防击穿、防雪崩完整方案
   - 缓存一致性保证机制

3. **智能状态机**
   - 支持超时自动处理
   - 状态历史追踪
   - 工作流引擎集成
   - 业务流程自动化

4. **实时性能监控**
   - 多维度性能指标收集
   - 智能告警和自动恢复
   - 业务数据分析
   - 用户行为追踪

本PRD文档通过详细的技术选型、架构设计和代码实现，确保了项目的技术可行性、业务完整性和系统可靠性。所有技术组件都经过精心选择和优化，形成了一个高性能、高可用、易维护的现代化电商Bot平台。
```
```
```
```python
# states.py - 状态机定义
from aiogram.fsm.state import State, StatesGroup

class UserStates(StatesGroup):
    MAIN_MENU = State()
    BROWSING_PRODUCTS = State()
    PRODUCT_DETAIL = State()
    CART_MANAGEMENT = State()
    CHECKOUT = State()
    WAITING_PAYMENT = State()
    ORDER_TRACKING = State()

class AdminStates(StatesGroup):
    ADMIN_MENU = State()
    MERCHANT_MANAGEMENT = State()
    ORDER_MANAGEMENT = State()
    FINANCIAL_REPORTS = State()
    USER_MANAGEMENT = State()

class MerchantStates(StatesGroup):
    MERCHANT_MENU = State()
    PRODUCT_MANAGEMENT = State()
    ADDING_PRODUCT = State()
    EDITING_PRODUCT = State()
    INVENTORY_MANAGEMENT = State()

class DeliveryStates(StatesGroup):
    DELIVERY_MENU = State()
    ORDER_LIST = State()
    ORDER_DETAIL = State()
    DELIVERY_UPDATE = State()
    CUSTOMER_CONTACT = State()
```

#### 数据库模型 (SQLModel)
```python
# models.py - 数据模型
from sqlmodel import SQLModel, Field, Relationship
from typing import Optional, List
from datetime import datetime
from enum import Enum

class MemberType(str, Enum):
    NORMAL = "normal"
    MONTHLY = "monthly"
    PERMANENT = "permanent"

class RoleType(str, Enum):
    SUPER_ADMIN = "super_admin"
    ADMIN = "admin"
    MERCHANT = "merchant"
    DELIVERY = "delivery"
    CUSTOMER_SERVICE = "customer_service"

class User(SQLModel, table=True):
    __tablename__ = "users"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(unique=True, index=True)  # Telegram User ID
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    language_code: str = Field(default="zh")
    country_id: Optional[int] = None
    region_id: Optional[int] = None
    balance: float = Field(default=0.0)
    points: int = Field(default=0)
    member_type: MemberType = Field(default=MemberType.NORMAL)
    member_expire_at: Optional[datetime] = None
    referrer_id: Optional[int] = None
    total_orders: int = Field(default=0)
    total_spent: float = Field(default=0.0)
    last_active_at: Optional[datetime] = None
    device_fingerprint: Optional[str] = None
    is_blocked: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    metadata: dict = Field(default_factory=dict, sa_column_kwargs={"type_": "JSONB"})
    
    # 关系
    roles: List["UserRole"] = Relationship(back_populates="user")
    orders: List["Order"] = Relationship(back_populates="user")

class UserRole(SQLModel, table=True):
    __tablename__ = "user_roles"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.user_id")
    role_type: RoleType
    admin_id: Optional[int] = None
    merchant_id: Optional[int] = None
    permission_data: dict = Field(default_factory=dict, sa_column_kwargs={"type_": "JSONB"})
    expire_at: Optional[datetime] = None
    status: str = Field(default="active")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    # 关系
    user: User = Relationship(back_populates="roles")

class Product(SQLModel, table=True):
    __tablename__ = "products"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    merchant_id: int = Field(foreign_key="merchants.id")
    category_id: int = Field(foreign_key="categories.id")
    name: str
    description: Optional[str] = None
    price_regular: float
    price_member: Optional[float] = None
    stock_quantity: int = Field(default=0)
    region_ids: List[int] = Field(sa_column_kwargs={"type_": "JSONB"})
    images: List[str] = Field(default_factory=list, sa_column_kwargs={"type_": "JSONB"})
    specifications: dict = Field(default_factory=dict, sa_column_kwargs={"type_": "JSONB"})
    is_member_only: bool = Field(default=False)
    status: str = Field(default="active")
    audit_status: str = Field(default="pending")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    # 关系
    merchant: "Merchant" = Relationship(back_populates="products")
    category: "Category" = Relationship(back_populates="products")
```

#### Redis缓存实现
```python
# cache.py - Redis缓存管理
import redis.asyncio as redis
import json
from typing import Any, Optional
from datetime import timedelta

class CacheManager:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        value = await self.redis.get(key)
        if value:
            return json.loads(value)
        return None
    
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        """设置缓存"""
        json_value = json.dumps(value, default=str)
        return await self.redis.setex(key, ttl, json_value)
    
    async def delete(self, key: str) -> bool:
        """删除缓存"""
        return await self.redis.delete(key)
    
    async def get_user_session(self, user_id: int) -> Optional[dict]:
        """获取用户会话"""
        return await self.get(f"session:user:{user_id}")
    
    async def set_user_session(self, user_id: int, session_data: dict) -> bool:
        """设置用户会话"""
        return await self.set(f"session:user:{user_id}", session_data, ttl=86400)
    
    async def get_product_cache(self, product_id: int) -> Optional[dict]:
        """获取商品缓存"""
        return await self.get(f"product:{product_id}")
    
    async def set_product_cache(self, product_id: int, product_data: dict) -> bool:
        """设置商品缓存"""
        return await self.set(f"product:{product_id}", product_data, ttl=1800)
    
    async def rate_limit_check(self, user_id: int, action: str, limit: int = 10, window: int = 60) -> bool:
        """频率限制检查"""
        key = f"rate_limit:{user_id}:{action}"
        current = await self.redis.incr(key)
        if current == 1:
            await self.redis.expire(key, window)
        return current <= limit
```

#### 管理员收款地址配置Bot命令实现

```python
# bot/admin_menu_handlers.py - 管理员菜单处理器
from aiogram import types, Router, F
from aiogram.filters import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from payment.admin_payment_config import AdminPaymentConfig, SupportedCurrency

router = Router()

class AdminPaymentStates(StatesGroup):
    """管理员收款地址配置状态"""
    waiting_currency_selection = State()
    waiting_address_input = State()
    waiting_priority_input = State()
    waiting_min_amount_input = State()

# ===== 资金管理菜单处理 =====

@router.callback_query(F.data == "admin_menu:financial")
async def handle_financial_menu(callback: types.CallbackQuery, admin_config: AdminPaymentConfig):
    """处理资金管理菜单"""
    user_id = callback.from_user.id
    
    # 检查管理员权限
    if not await _is_admin(user_id):
        await callback.answer("❌ 权限不足", show_alert=True)
        return
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="💳 收款配置", callback_data="financial:payment_config")],
        [InlineKeyboardButton(text="📊 商家订单收款", callback_data="financial:merchant_orders")],
        [InlineKeyboardButton(text="💰 提现管理", callback_data="financial:withdrawals")],
        [InlineKeyboardButton(text="📈 财务报表", callback_data="financial:reports")],
        [InlineKeyboardButton(text="🏦 商家结算", callback_data="financial:settlements")],
        [InlineKeyboardButton(text="🔙 返回主菜单", callback_data="admin_menu:main")]
    ])
    
    await callback.message.edit_text(
        "🏦 **资金管理**\n\n"
        "请选择要管理的功能：",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@router.callback_query(F.data == "financial:payment_config")
async def handle_payment_config_menu(callback: types.CallbackQuery, admin_config: AdminPaymentConfig):
    """处理收款配置菜单"""
    # 获取当前所有配置的收款地址
    addresses = await admin_config.get_all_payment_addresses()
    
    # 构建键盘
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="➕ 添加收款地址", callback_data="payment_config:add")],
        [InlineKeyboardButton(text="📋 查看所有地址", callback_data="payment_config:list")],
        [InlineKeyboardButton(text="🔄 刷新配置", callback_data="payment_config:refresh")],
        [InlineKeyboardButton(text="⚙️ 支付参数设置", callback_data="payment_config:settings")],
        [InlineKeyboardButton(text="🔙 返回资金管理", callback_data="admin_menu:financial")]
    ])
    
    # 构建状态信息
    status_text = "💳 **管理员收款地址配置**\n\n"
    status_text += "🎯 **用途**：商家入驻费用收款\n"
    status_text += "🌐 **支持币种**：BTC、ETH、USDT(TRC20/ERC20)、TRX\n\n"
    
    if addresses:
        status_text += "📊 **当前配置状态：**\n"
        for addr in addresses[:3]:  # 显示前3个
            status_emoji = "✅" if addr.is_active else "❌"
            status_text += f"{status_emoji} {addr.currency.display_name} (优先级: {addr.priority})\n"
        
        if len(addresses) > 3:
            status_text += f"... 还有 {len(addresses) - 3} 个地址\n"
            
        status_text += f"\n💰 共配置 {len(addresses)} 种收款方式"
    else:
        status_text += "⚠️ **尚未配置任何收款地址**\n\n"
        status_text += "❗ 请先添加收款地址以启用商家入驻付费功能\n"
        status_text += "💡 建议优先配置 USDT 地址，用户使用最多"
    
    await callback.message.edit_text(status_text, reply_markup=keyboard, parse_mode="Markdown")

@router.callback_query(F.data == "payment_config:add")
async def handle_add_payment_address(callback: types.CallbackQuery, state: FSMContext):
    """处理添加收款地址"""
    await state.set_state(AdminPaymentStates.waiting_currency_selection)
    
    # 构建货币选择键盘
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="💵 USDT (TRC20)", callback_data="currency:usdt_trc20"),
            InlineKeyboardButton(text="� USDT (ERC20)", callback_data="currency:usdt_erc20")
        ],
        [
            InlineKeyboardButton(text="₿ 比特币 (BTC)", callback_data="currency:bitcoin"),
            InlineKeyboardButton(text="� 以太坊 (ETH)", callback_data="currency:ethereum")
        ],
        [InlineKeyboardButton(text="🔥 波场币 (TRX)", callback_data="currency:tron")],
        [InlineKeyboardButton(text="🔙 返回收款配置", callback_data="financial:payment_config")]
    ])
    
    await callback.message.edit_text(
        "📋 **选择要配置的加密货币类型**\n\n"
        "💡 **推荐配置优先级：**\n"
        "1️⃣ USDT (TRC20) - 手续费低，到账快\n"
        "2️⃣ USDT (ERC20) - 生态完善，支持广泛\n"
        "3️⃣ BTC/ETH - 主流币种，价值稳定\n"
        "4️⃣ TRX - 波场生态，转账便宜\n\n"
        "请选择您要添加收款地址的加密货币：",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@router.callback_query(F.data.startswith("currency:"))
async def handle_currency_selection(callback: types.CallbackQuery, state: FSMContext):
    """处理货币选择"""
    currency_value = callback.data.split(":")[1]
    currency = SupportedCurrency(currency_value)
    
    await state.update_data(selected_currency=currency)
    await state.set_state(AdminPaymentStates.waiting_address_input)
    
    # 获取地址格式说明
    format_info = _get_address_format_info(currency)
    
    await callback.message.edit_text(
        f"💳 **配置 {currency.display_name} 收款地址**\n\n"
        f"🌐 **网络**：{currency.network}\n"
        f"⚡ **确认区块**：{_get_default_confirmations(currency)}\n\n"
        f"📝 **地址格式要求：**\n{format_info}\n\n"
        f"💬 请发送您的 {currency.display_name} 收款地址：\n\n"
        f"⚠️ **注意**：请确保地址准确无误，错误地址将导致资金丢失！",
        parse_mode="Markdown"
    )

@router.message(StateFilter(AdminPaymentStates.waiting_address_input))
async def handle_address_input(message: types.Message, state: FSMContext, admin_config: AdminPaymentConfig):
    """处理地址输入"""
    address = message.text.strip()
    data = await state.get_data()
    currency = data["selected_currency"]
    
    # 验证地址格式
    if not await admin_config._validate_address(currency, address):
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 重新输入", callback_data="payment_config:add")],
            [InlineKeyboardButton(text="🔙 返回", callback_data="financial:payment_config")]
        ])
        
        await message.reply(
            f"❌ **地址格式错误**\n\n"
            f"您输入的 {currency.display_name} 地址格式不正确。\n\n"
            f"📝 **正确格式要求：**\n{_get_address_format_info(currency)}\n\n"
            f"💡 **常见错误：**\n"
            f"• 地址长度不符合要求\n"
            f"• 地址前缀不正确\n"
            f"• 包含无效字符\n\n"
            f"请重新检查并输入正确的地址。",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
        return
    
    await state.update_data(address=address)
    await state.set_state(AdminPaymentStates.waiting_priority_input)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1 (最高)", callback_data="priority:1"),
            InlineKeyboardButton(text="2", callback_data="priority:2"),
            InlineKeyboardButton(text="3", callback_data="priority:3")
        ],
        [
            InlineKeyboardButton(text="4", callback_data="priority:4"),
            InlineKeyboardButton(text="5", callback_data="priority:5"),
            InlineKeyboardButton(text="其他", callback_data="priority:custom")
        ]
    ])
    
    await message.reply(
        f"✅ **地址验证通过**\n\n"
        f"💳 **货币**：{currency.display_name}\n"
        f"📍 **地址**：`{address}`\n\n"
        f"🔢 **设置优先级** (1-10，数字越小优先级越高)：\n\n"
        f"💡 **推荐配置：**\n"
        f"• USDT：1-2 (主要推荐给用户)\n"
        f"• BTC/ETH：3-5 (作为备选)\n"
        f"• TRX：6-10 (补充选择)\n\n"
        f"请选择优先级：",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@router.callback_query(F.data.startswith("priority:"))
async def handle_priority_selection(callback: types.CallbackQuery, state: FSMContext):
    """处理优先级选择"""
    priority_value = callback.data.split(":")[1]
    
    if priority_value == "custom":
        await callback.message.edit_text(
            "🔢 **自定义优先级**\n\n"
            "请发送一个 1-10 之间的数字：\n"
            "（数字越小，优先级越高）",
            parse_mode="Markdown"
        )
        return
    
    priority = int(priority_value)
    await state.update_data(priority=priority)
    await state.set_state(AdminPaymentStates.waiting_min_amount_input)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="0 (无限制)", callback_data="amount:0"),
            InlineKeyboardButton(text="10 USD", callback_data="amount:10")
        ],
        [
            InlineKeyboardButton(text="100 USD", callback_data="amount:100"),
            InlineKeyboardButton(text="1000 USD", callback_data="amount:1000")
        ],
        [InlineKeyboardButton(text="自定义金额", callback_data="amount:custom")]
    ])
    
    await callback.message.edit_text(
        f"✅ **优先级设置完成：{priority}**\n\n"
        f"💰 **设置最小收款金额** (USD)：\n\n"
        f"💡 **参考标准：**\n"
        f"• 商家保证金：1000 USD\n"
        f"• 商家月租金：300 USD\n"
        f"• 小额支付：10 USD\n"
        f"• 无限制：0 USD\n\n"
        f"请选择最小金额：",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@router.callback_query(F.data.startswith("amount:"))
async def handle_amount_selection(callback: types.CallbackQuery, state: FSMContext, admin_config: AdminPaymentConfig):
    """处理金额选择"""
    amount_value = callback.data.split(":")[1]
    
    if amount_value == "custom":
        await callback.message.edit_text(
            "💰 **自定义最小金额**\n\n"
            "请发送最小金额数字 (USD)：\n"
            "（输入 0 表示无限制）",
            parse_mode="Markdown"
        )
        return
    
    min_amount = float(amount_value)
    
    # 获取所有配置数据
    data = await state.get_data()
    currency = data["selected_currency"]
    address = data["address"]
    priority = data["priority"]
    
    # 保存配置
    success = await admin_config.set_payment_address(
        currency=currency,
        address=address,
        priority=priority,
        min_amount=min_amount
    )
    
    if success:
        # 构建确认消息
        confirm_text = (
            f"✅ **收款地址配置成功！**\n\n"
            f"💳 **货币**：{currency.display_name}\n"
            f"🌐 **网络**：{currency.network}\n"
            f"📍 **地址**：`{address}`\n"
            f"🔢 **优先级**：{priority}\n"
            f"💰 **最小金额**：${min_amount}\n"
            f"⚡ **确认区块**：{_get_default_confirmations(currency)}\n\n"
            f"🎉 **配置已生效**\n"
            f"商家入驻时可以使用此地址收款！"
        )
        
        # 构建返回键盘
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ 继续添加", callback_data="payment_config:add")],
            [InlineKeyboardButton(text="📋 查看所有", callback_data="payment_config:list")],
            [InlineKeyboardButton(text="🏠 返回资金管理", callback_data="admin_menu:financial")]
        ])
        
        await callback.message.edit_text(confirm_text, reply_markup=keyboard, parse_mode="Markdown")
    else:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 重试", callback_data="payment_config:add")],
            [InlineKeyboardButton(text="🔙 返回", callback_data="financial:payment_config")]
        ])
        
        await callback.message.edit_text(
            "❌ **配置保存失败**\n\n"
            "可能的原因：\n"
            "• 数据库连接问题\n"
            "• 地址已存在\n"
            "• 系统繁忙\n\n"
            "请稍后重试或联系技术支持。",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
    
    await state.clear()

@router.message(StateFilter(AdminPaymentStates.waiting_priority_input))
async def handle_priority_text_input(message: types.Message, state: FSMContext):
    """处理优先级文本输入"""
    try:
        priority = int(message.text.strip())
        if not 1 <= priority <= 10:
            raise ValueError("Priority out of range")
    except ValueError:
        await message.reply(
            "❌ **优先级格式错误**\n\n"
            "请输入 1-10 之间的整数（数字越小优先级越高）"
        )
        return
    
    await state.update_data(priority=priority)
    await state.set_state(AdminPaymentStates.waiting_min_amount_input)
    
    await message.reply(
        f"✅ **优先级设置完成：{priority}**\n\n"
        f"💰 **设置最小收款金额** (USD)：\n\n"
        f"建议配置：\n"
        f"• 商家保证金：1000 USD\n"
        f"• 商家租金：300 USD\n"
        f"• 小额支付：10 USD\n\n"
        f"请输入最小金额（输入 0 表示无限制）："
    )

@router.message(StateFilter(AdminPaymentStates.waiting_min_amount_input))
async def handle_min_amount_text_input(message: types.Message, state: FSMContext, admin_config: AdminPaymentConfig):
    """处理最小金额文本输入"""
    try:
        min_amount = float(message.text.strip())
        if min_amount < 0:
            raise ValueError("Negative amount")
    except ValueError:
        await message.reply(
            "❌ **金额格式错误**\n\n"
            "请输入有效的数字金额（可以是小数，不能为负数）"
        )
        return
    
    # 获取所有配置数据
    data = await state.get_data()
    currency = data["selected_currency"]
    address = data["address"]
    priority = data["priority"]
    
    # 保存配置
    success = await admin_config.set_payment_address(
        currency=currency,
        address=address,
        priority=priority,
        min_amount=min_amount
    )
    
    if success:
        # 构建确认消息
        confirm_text = (
            f"✅ **收款地址配置成功！**\n\n"
            f"💳 货币：{currency.display_name}\n"
            f"🌐 网络：{currency.network}\n"
            f"📍 地址：`{address}`\n"
            f"🔢 优先级：{priority}\n"
            f"💰 最小金额：${min_amount}\n\n"
            f"⚡ 配置已生效，商家入驻时可以使用此地址收款。"
        )
        
        # 构建返回键盘
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ 继续添加", callback_data="payment_config:add")],
            [InlineKeyboardButton(text="📋 查看所有", callback_data="payment_config:list")],
            [InlineKeyboardButton(text="🏠 返回资金管理", callback_data="admin_menu:financial")]
        ])
        
        await message.reply(confirm_text, reply_markup=keyboard, parse_mode="Markdown")
    else:
        await message.reply(
            "❌ **配置保存失败**\n\n"
            "请检查配置信息并重试，或联系技术支持。"
        )
    
    await state.clear()

@router.callback_query(F.data == "payment_config:list")
async def handle_list_addresses(callback: types.CallbackQuery, admin_config: AdminPaymentConfig):
    """查看所有收款地址"""
    addresses = await admin_config.get_all_payment_addresses()
    
    if not addresses:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ 添加地址", callback_data="payment_config:add")],
            [InlineKeyboardButton(text="🔙 返回", callback_data="financial:payment_config")]
        ])
        
        await callback.message.edit_text(
            "📭 **暂无配置的收款地址**\n\n"
            "请先添加收款地址以启用商家收款功能。\n\n"
            "💡 建议优先配置 USDT 地址，用户接受度最高。",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
        return
    
    # 构建地址列表
    list_text = "📋 **所有收款地址配置**\n\n"
    
    for i, addr in enumerate(addresses, 1):
        status_emoji = "✅" if addr.is_active else "❌"
        list_text += f"{i}. {status_emoji} **{addr.currency.display_name}**\n"
        list_text += f"   🌐 网络：{addr.network}\n"
        list_text += f"   📍 地址：`{addr.address[:15]}...{addr.address[-15:]}`\n"
        list_text += f"   🔢 优先级：{addr.priority}\n"
        list_text += f"   💰 最小金额：${addr.min_amount}\n"
        list_text += f"   🔗 确认区块：{addr.confirmation_blocks}\n\n"
    
    # 构建操作键盘
    keyboard_rows = []
    
    # 每行显示2个币种的操作按钮
    for i in range(0, len(addresses), 2):
        row = []
        for j in range(i, min(i + 2, len(addresses))):
            addr = addresses[j]
            toggle_text = "❌ 禁用" if addr.is_active else "✅ 启用"
            row.append(InlineKeyboardButton(
                text=f"{addr.currency.display_name} {toggle_text}",
                callback_data=f"toggle_addr:{addr.currency.value}"
            ))
        keyboard_rows.append(row)
    
    keyboard_rows.extend([
        [InlineKeyboardButton(text="➕ 添加新地址", callback_data="payment_config:add")],
        [InlineKeyboardButton(text="🔄 刷新列表", callback_data="payment_config:list")],
        [InlineKeyboardButton(text="🔙 返回收款配置", callback_data="financial:payment_config")]
    ])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=keyboard_rows)
    
    await callback.message.edit_text(list_text, reply_markup=keyboard, parse_mode="Markdown")

@router.callback_query(F.data.startswith("toggle_addr:"))
async def handle_toggle_address(callback: types.CallbackQuery, admin_config: AdminPaymentConfig):
    """切换地址启用/禁用状态"""
    currency_value = callback.data.split(":")[1]
    currency = SupportedCurrency(currency_value)
    
    # 获取当前地址信息
    addr = await admin_config.get_payment_address(currency)
    if not addr:
        await callback.answer("❌ 地址不存在", show_alert=True)
        return
    
    if addr.is_active:
        # 禁用地址
        success = await admin_config.disable_payment_address(currency)
        action = "禁用"
    else:
        # 启用地址（重新设置）
        success = await admin_config.set_payment_address(
            currency=currency,
            address=addr.address,
            priority=addr.priority,
            min_amount=addr.min_amount
        )
        action = "启用"
    
    if success:
        await callback.answer(f"✅ {currency.display_name} 地址已{action}")
        # 刷新列表
        await handle_list_addresses(callback, admin_config)
    else:
        await callback.answer(f"❌ {action}失败", show_alert=True)

# ===== 工具函数 =====

def _get_address_format_info(currency: SupportedCurrency) -> str:
    """获取地址格式说明"""
    format_info = {
        SupportedCurrency.BTC: "• 长度：25-35字符\n• 开头：1、3 或 bc1\n• 示例：1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
        SupportedCurrency.ETH: "• 长度：42字符\n• 开头：0x\n• 示例：0x742d35Cc6Bc003C3Dd02B16b6C4f7A4C5F0dB3C3",
        SupportedCurrency.USDT_ERC20: "• 长度：42字符\n• 开头：0x\n• 示例：0x742d35Cc6Bc003C3Dd02B16b6C4f7A4C5F0dB3C3",
        SupportedCurrency.USDT_TRC20: "• 长度：34字符\n• 开头：T\n• 示例：TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs",
        SupportedCurrency.TRX: "• 长度：34字符\n• 开头：T\n• 示例：TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs"
    }
    return format_info.get(currency, "请输入有效的钱包地址")

def _get_default_confirmations(currency: SupportedCurrency) -> int:
    """获取默认确认区块数"""
    confirmations = {
        SupportedCurrency.BTC: 1,
        SupportedCurrency.ETH: 12,
        SupportedCurrency.USDT_ERC20: 12,
        SupportedCurrency.USDT_TRC20: 1,
        SupportedCurrency.TRX: 1
    }
    return confirmations.get(currency, 1)

async def _is_admin(user_id: int) -> bool:
    """检查用户是否为管理员"""
    # 这里应该实现真实的管理员权限检查
    # 可以从数据库或配置文件中读取管理员列表
    admin_ids = [123456789, 987654321]  # 示例管理员ID列表
    return user_id in admin_ids

# ===== 前端用户商家入驻菜单处理 =====

@router.callback_query(F.data == "user_menu:member_merchant")
async def handle_member_merchant_menu(callback: types.CallbackQuery):
    """处理会员商家菜单"""
    user_id = callback.from_user.id
    
    # 检查用户会员状态
    is_member = await _check_user_membership(user_id)
    
    if not is_member:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💎 成为会员", callback_data="membership:upgrade")],
            [InlineKeyboardButton(text="📱 查看会员权益", callback_data="membership:benefits")],
            [InlineKeyboardButton(text="🔙 返回主菜单", callback_data="user_menu:main")]
        ])
        
        await callback.message.edit_text(
            "👑 **会员商家中心**\n\n"
            "❗ 您还不是会员用户\n\n"
            "🎯 **会员专享权益：**\n"
            "• 查看会员专属商品\n"
            "• 享受9折购买优惠\n"
            "• 申请商家入驻资格\n"
            "• 专属客服通道\n\n"
            "请先成为会员后再申请商家入驻。",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
        return
    
    # 检查是否已经是商家
    is_merchant = await _check_merchant_status(user_id)
    
    if is_merchant:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🏪 商家管理", callback_data="merchant:dashboard")],
            [InlineKeyboardButton(text="📊 商家数据", callback_data="merchant:analytics")],
            [InlineKeyboardButton(text="💰 财务结算", callback_data="merchant:finance")],
            [InlineKeyboardButton(text="🔙 返回主菜单", callback_data="user_menu:main")]
        ])
        
        await callback.message.edit_text(
            "🏪 **商家管理中心**\n\n"
            "✅ 您已经是认证商家\n\n"
            "🎯 **可用功能：**\n"
            "• 商品管理和上架\n"
            "• 订单处理和配送\n"
            "• 财务数据查看\n"
            "• 客户服务管理",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
        return
    
    # 会员但非商家，显示入驻选项
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🚀 申请商家入驻", callback_data="merchant:apply")],
        [InlineKeyboardButton(text="📋 入驻要求说明", callback_data="merchant:requirements")],
        [InlineKeyboardButton(text="💰 费用标准", callback_data="merchant:pricing")],
        [InlineKeyboardButton(text="🔙 返回主菜单", callback_data="user_menu:main")]
    ])
    
    await callback.message.edit_text(
        "👑 **会员商家中心**\n\n"
        "🎉 欢迎会员用户！\n\n"
        "🏪 **商家入驻优势：**\n"
        "• 🌍 覆盖全球市场\n"
        "• 💰 灵活定价策略\n"
        "• 📱 便捷管理工具\n"
        "• 🚀 快速开店流程\n\n"
        "💡 **简化入驻流程：**\n"
        "无需营业执照 → 选择地区 → 在线支付 → 即时开通",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

#### 商家入驻申请功能设计

**商家入驻申请流程描述**：

1. **入驻申请触发**：
   - 会员用户点击"商家入驻"按钮
   - 系统检查用户会员状态和商家资格
   - 引导用户进入地区选择界面

2. **国家选择界面**：
   - 显示支持的国家列表（仅限硬性数据中的8个国家）：
     * 🇹🇭 泰国 (Thailand)
     * 🇻🇳 越南 (Vietnam)  
     * 🇱🇦 老挝 (Laos)
     * 🇲🇲 缅甸 (Myanmar)
     * �� 迪拜 (Dubai)
     * �� 马来西亚 (Malaysia)
     * 🇸🇬 新加坡 (Singapore)
     * 🇰🇷 韩国 (South Korea)
   - 进入对应国家的地区列表：
   -提供"其他地区"选项供手动输入
   - 每个地区需要单独申请入驻
   - 不同地区的费用标准可能不同

3. **费用展示界面**：
   - 显示选中地区的入驻费用明细
   - 保证金：1000 USD（基准金额，可动态调整）
   - 首月租金：300 USD（固定金额）
   - 总计费用：1300 USD
   - 费用说明：保证金用于确保服务质量，租金按月收取

4. **支付方式选择**：
   - 显示管理员配置的收款地址选项
   - 按优先级排序显示支持的加密货币
   - 自动计算实时汇率（USD转换为加密货币）
   - 生成30分钟有效期的支付发票

5. **支付确认流程**：
   - 用户完成转账后系统监控到账状态
   - 支付确认后自动触发商家权限开通
   - 自动生成商家Bot授权链接
   - 发送入驻成功通知和后续操作指引

**界面交互设计要求**：
- 简洁直观的按钮布局
- 清晰的费用和流程说明
- 实时的支付状态更新
- 友好的错误提示和重试机制
- 支持返回上一步和取消操作

**系统后台处理**：
- 记录申请过程中的所有状态变化
- 自动生成唯一的申请编号
- 支付成功后触发权限变更工作流
- 发送通知给相关管理员
- 更新用户角色和权限数据

#### 地区选择功能设计

**地区选择界面描述**：

1. **界面布局要求**：
   - 按行显示支持的国家，每行2个国家按钮
   - 使用国旗emoji + 国家名称的格式
   - 按钮排列顺序：
     * 第一行：🇹🇭 泰国、🇻🇳 越南
     * 第二行：🇱🇦 老挝、🇲🇲 缅甸  
     * 第三行：🇦🇪 迪拜、🇲🇾 马来西亚
     * 第四行：🇸🇬 新加坡、🇰🇷 韩国
   - 底部提供"🌍 其他地区"和"🔙 返回"选项

2. **交互逻辑说明**：
   - 用户点击具体国家后跳转到费用展示页面
   - 点击"其他地区"进入自定义输入模式
   - 点击"返回"回到会员商家中心
   - 每个选择都有相应的回调数据标识

3. **费用展示页面设计**：
   - 显示选中地区名称
   - 列出详细费用明细：
     * 保证金：1000 USD（基准）
     * 首月租金：300 USD（固定）
     * 合计：1300 USD
   - 说明费用用途和支付后的权限开通

4. **支付方式选择设计**：
   - 按优先级显示前3个可用的加密货币
   - 每个支付方式显示货币名称和网络信息
   - 提供"查看更多支付方式"选项
   - 支持返回重新选择地区

**自定义地区输入功能**：
- 引导用户输入地区名称
- 验证输入内容的有效性  
- 支持多语言地区名称
- 后续流程与选择预设地区相同

**支付确认流程设计**：
- 自动生成唯一支付订单号
- 显示准确的加密货币支付金额
- 提供收款地址和支付说明
- 30分钟支付有效期倒计时
- 实时监控支付状态更新

#### 用户身份验证功能

**会员身份检查逻辑**：
    
    await callback.message.edit_text(
**支付流程与商家入驻集成**

**支付流程启动机制**：
- 计算用户选择地区的总费用（保证金+首月租金）
- 自动选择推荐的支付货币
- 生成唯一支付发票和收款信息
- 返回完整的支付指引和说明

**支付发票生成规则**：
- 包含订单号、金额、收款地址
- 自动计算加密货币兑换金额
- 设置30分钟支付有效期
- 记录支付目的和用户信息

**支付监控与确认**：
- 实时监控区块链交易状态
- 自动匹配交易金额和地址
- 支付成功后立即权限升级
- 异常情况下支持人工干预

**商家权限开通流程**：
- 验证支付完成状态
- 自动升级用户权限等级
- 发送权限开通确认消息
- 记录商家入驻档案信息
            
        except Exception as e:
            logger.error("Failed to start merchant payment", user_id=user_id, error=str(e))
            return {
                "success": False,
                "error": "支付流程启动失败，请重试"
            }
    
    def _get_payment_instructions(self, invoice: Dict[str, Any]) -> str:
        """获取支付说明"""
        return (
            f"💳 **商家入驻费用支付**\n\n"
            f"📋 支付信息：\n"
            f"💰 支付金额：{invoice['amount_crypto']} {invoice['currency_display']}\n"
            f"🌐 网络：{invoice['network']}\n"
            f"📍 收款地址：\n`{invoice['address']}`\n\n"
            f"⚠️ **重要提醒：**\n"
            f"• 请确保转账金额准确无误\n"
            f"• 请在30分钟内完成转账\n"
            f"• 转账后请等待区块确认\n"
            f"• 确认后系统将自动开通商家权限\n\n"
            f"🔍 支付ID：`{invoice['payment_id']}`\n"
            f"⏰ 有效期至：{invoice['expires_at']}"
